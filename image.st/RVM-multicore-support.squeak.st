'****************************************************************************** *  Copyright (c) 2008 - 2010 IBM Corporation and others. *  All rights reserved. This program and the accompanying materials *  are made available under the terms of the Eclipse Public License v1.0 *  which accompanies this distribution, and is available at *  http://www.eclipse.org/legal/epl-v10.html *  *  Contributors: *    David Ungar, IBM Research - Initial Implementation *    Sam Adams, IBM Research - Initial Implementation *    Stefan Marr, Vrije Universiteit Brussel - Port to x86 Multi-Core Systems ******************************************************************************'!DisplayText subclass: #Paragraph	instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine destFormSema'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'ST80-Support'!PluggableTextMorph subclass: #PluggableTextMorphPlus	instanceVariableNames: 'getColorSelector acceptAction unstyledAcceptText styler textInterlock'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler name island env hostCore coreMask'	classVariableNames: 'SemaForSuspensions'	poolDictionaries: ''	category: 'Kernel-Processes'!Object subclass: #RVMPrimitives	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RVM-Support'!Object subclass: #SHTextStyler	instanceVariableNames: 'sem backgroundProcess text monitor view stylingEnabled textInterlock'	classVariableNames: ''	poolDictionaries: ''	category: 'ShoutCore-Styling'!	Object subclass: #ProcessorScheduler	instanceVariableNames: 'quiescentProcessLists activeProcess'	classVariableNames: 'BackgroundProcess EmergencyProcess HighIOPriority LowIOPriority SystemBackgroundPriority SystemRockBottomPriority TimingPriority UserBackgroundPriority UserInterruptPriority UserSchedulingPriority'	poolDictionaries: ''	category: 'Kernel-Processes'!FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1 interlock'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'System-Files'!View subclass: #StandardSystemView	instanceVariableNames: 'labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize collapsedViewport expandedViewport labelBits windowBits bitsValid updatablePanes displayInterlock'	classVariableNames: 'CacheBits LabelStyle'	poolDictionaries: ''	category: 'ST80-Support'!Object subclass: #Mutex	instanceVariableNames: 'semaphore owner'	classVariableNames: ''	poolDictionaries: ''	category: 'RVM-Support'!!ProcessorScheduler methodsFor: 'accessing' stamp: 'dmu 11/25/2008 00:23'!activePriority	"Answer the priority level of the currently running Process."	^self thisProcess priority! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'dmu 9/16/2010 14:53'!preemptedProcess	"Return the process that the currently active process just preempted."	| list listWithoutMe |	self thisProcess priority to: 1 by: -1 do:[:priority|		list := quiescentProcessLists at: priority.		"RVM keeps running processes on the lists -- dmu 9/16/10"		listWithoutMe := list reject: [:p | p == Processor thisProcess].		listWithoutMe isEmpty ifFalse:[^listWithoutMe last].	].	^nil	"Processor preemptedProcess"! !!ProcessorScheduler methodsFor: 'process state change' stamp: 'dmu 11/25/2008 00:23'!terminateActive	"Terminate the process that is currently running."	self thisProcess terminate! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:39'!areRunningProcessesInSchedulerLists	"Our RVM follows Pallas' MS system and keeps runnable processes in the scheduler lists even when running."	^RVMPrimitives isRVM! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 11/25/2008 00:26'!isActive: aProcess	^ aProcess suspendedContext ==  nil! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:32'!thisProcess	^ RVMPrimitives thisProcess! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 3/22/2010 13:03'!yieldIfFewerCoresThan: n	RVMPrimitives coreCount < n    ifTrue: [self yield]! !!Project class methodsFor: 'utilities' stamp: 'dmu 11/25/2008 00:24'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor thisProcess suspend]! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/8/2010 23:41'!breakpoint	<primitive: 'primitiveBreakpoint' module: 'RVMPrimitives'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:02'!printExecutionTrace	<primitive: 'primitivePrintExecutionTrace' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:01'!printOnConsole: aString	"Prints a string onto the console"	<primitive: 'primitivePrint' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:00'!printStack	"Prints Smalltalk stack to console"	<primitive: 'primitivePrintStack' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:01'!printVMStatistics	<primitive: 'primitivePrintStats' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'VM statistics' stamp: 'dmu 6/8/2010 23:04'!sampleRVM	"Grab some data from the VM and return it"	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>	"RVMPrimitives sampleRVM"	^ nil! !!RVMPrimitives class methodsFor: 'VM statistics' stamp: 'sm 10/27/2010 22:09'!getMainRank	"Get a sample from the VM and read out the main rank"	| sample |	sample := self sampleRVM.	^ ((sample at: 6) at: 2) at: 6! !!RVMPrimitives class methodsFor: 'VM statistics' stamp: 'dmu 6/8/2010 23:40'!sampleSpecificData: flags	"Grab some data from the VM and return it"	"Bit offsets for flags; bit 0 is 1, bit 1 is 2, bit 2 is 4, etc.		allCores, // 0	runMask,	messageNames,	cpuCoreStats,	allCoreStats,	fence,	millisecs, // 6	cycles,	messageStats,	memorySystemStats,    	interpreterStats,    	objectTableStats,    	interactionStats,   	 coreCoords, // 14    	sendTallies,    	receiveTallies,    	bufferedMessageStats,    	receiveCycles,    	// memory system    	gcStats, // 19    	heapStats,    	// interpreter    	bytecodes, // 20    	yieldCount,    	cycleCounts,    	interruptChecks,    	movedMutatedObjectStats,    	mutexStats,   	 interpreterLoopStats // 26"	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>	^ nil! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:58'!moveAllToReadMostlyHeaps	"Move all objects into read-mostly heaps"	<primitive: 'primitiveMoveAllToReadMostlyHeaps' module: 'RVMPlugin'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:55'!shuffleToHeapsFrom: firstHeap to: lastHeap	"Deal out all objects in the system into heaps from firstHeap through lastHeap in round-robin fashion so that adjacent objects wind up in different heaps"	<primitive: 'primitiveShuffle' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:56'!shuffleToHeapsFrom: firstHeap to: lastHeap movingReadWriteObjectsToReadMostlyHeap: rwToRM  movingReadMostlyObjectsToReadWriteHeap: rmToRw	"Deal out all objects in the system into heaps from firstHeap through lastHeap in round-robin fashion so that adjacent objects wind up in different heaps"	"If rwToRM, move objects in read/write heaps to read-mostly heaps."	"If rmToRW, move objects in read-mostly heaps to read/write heaps."	<primitive: 'primitiveShuffle' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:57'!spreadToHeapsFrom: firstHeap to: lastHeap	"Spread out all objects in the system into heaps from firstHeap through lastHeap so that each heap ends up about equally full."	<primitive: 'primitiveSpread' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:57'!spreadToHeapsFrom: firstHeap to: lastHeap movingReadWriteObjectsToReadMostlyHeap: rwToRM  movingReadMostlyObjectsToReadWriteHeap: rmToRw	"Spread out all objects in the system into heaps from firstHeap through lastHeap so that each heap ends up about equally full."	"If rwToRM, move objects in read/write heaps to read-mostly heaps."	"If rmToRW, move objects in read-mostly heaps to read/write heaps."	<primitive: 'primitiveSpread' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:30'!for: anObject setRankTo: rank	<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:31'!for: anObject setRankTo: rank isReadWrite: isRW	<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:17'!getCoreOf: anObject	"RVMPrimitives getCoreOf: 2@3"	<primitive: 'primitiveGetCore' module: 'RVMPlugin'>	^ -1! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:47'!getMutabilityOf: anObject	"Return true if argument is in a read/write heap, false if in read-mostly heap"	<primitive: 'primitiveGetMutability' module: 'RVMPlugin'>	^ true! !!RVMPrimitives class methodsFor: 'enumerating a heap' stamp: 'dmu 6/8/2010 23:10'!allObjectsInHeap: rank isReadWrite: trueForReadWriteFalseForReadMostly	"return array of all objects in either read/write or read-mostly heap specified by rank and trueForReadWriteFalseForReadMostly"	"RVMPrimitives allObjectsInHeap: 0 isReadWrite: true"	<primitive: 'primitiveAllObjectsInHeap' module: 'RVMPlugin'>	^ nil! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/8/2010 23:18'!getCoreIAmRunningOn	"RVMPrimitives getCoreIAmRunningOn"	<primitive: 'primitiveGetCoreIAmRunningOn' module: 'RVMPlugin' >  	^ -1! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/8/2010 23:44'!getRunMask	"Return an integer with ones corresponding to cores RVM is allowed to use: 1 means core 0, 3 means cores 0 and 1, etc."	"RVMPrimitives getRunMask printStringBase: 16"	<primitive: 'primitiveRunMask' module: 'RVMPlugin'>	^ -1! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/9/2010 00:07'!getRunningProcessesByCore	"Returns array of running processes, indexed by core (+1)"	<primitive: 'primitiveRunningProcessByCore' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/8/2010 23:46'!setRunMask: anInteger	"Sets run mask to argument and returns old run mask.	Only cores set in run mask will be used to run Smalltalk processes."	"RVMPrimitives setRunMask: 1"	<primitive: 'primitiveRunMask' module: 'RVMPlugin'>	^ -1! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/9/2010 00:04'!thisProcess	"Return the process that is running; RVM does not use ActiveProcess for this state, since many may be running"	<primitive: 'primitiveThisProcess'  module: 'RVMPlugin'>	^ Processor activeProcess! !!RVMPrimitives class methodsFor: 'cores' stamp: 'dmu 6/8/2010 23:11'!coreCount  "RVMPrimitives coreCount"  <primitive: 'primitiveCoreCount' module: 'RVMPlugin'>  ^ 1! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:25'!getCoreTrace	"RVMPrimitives getCoreTrace"	<primitive: 'primitiveTraceCores' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:26'!getMutatedReplicatedObjectsTrace	<primitive: 'primitiveTraceMutatedReplicatedObjects' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:22'!startCoreTrace: size	"RVMPrimitives startCoreTrace: 1000"	<primitive: 'primitiveTraceCores' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:27'!startMutatedReplicatedObjectsTrace: size	<primitive: 'primitiveTraceMutatedReplicatedObjects' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'emergency evaluating' stamp: 'dmu 6/8/2010 23:19'!getEmergencySemaphore	"When you hit shift-control-a, the VM will signal the emergency semaphore, if it has been set to a semaphore"	"RVMPrimitives getEmergencySemaphore"	<primitive: 'primitiveEmergencySemaphore' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'emergency evaluating' stamp: 'dmu 6/9/2010 00:06'!setEmergencySemaphore: aSema	"When you hit shift-control-a, the VM will signal the emergency semaphore, if it has been set to a semaphore"	"RVMPrimitives setEmergencySemaphore: Semaphore new"	<primitive: 'primitiveEmergencySemaphore' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'using extra word' stamp: 'dmu 6/14/2010 15:27'!getExtraPreheaderWordOf: anObject	"Returns the extra preheader word of the argument."	"RVMPrimitives getExtraPreheaderWordOf: 3@4"	<primitive: 'primitiveGetExtraPreheaderWord' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'using extra word' stamp: 'dmu 6/14/2010 15:27'!setExtraPreheaderWordOf: anObject to: newContents	"Sets the extra preheader word of the first argument."	"|n| n := 3@4.	RVMPrimitives setExtraPreheaderWordOf: n to: 17.	RVMPrimitives getExtraPreheaderWordOf: n"	<primitive: 'primitiveSetExtraPreheaderWord' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'using extra word' stamp: 'dmu 6/9/2010 00:05'!setExtraWordSelector: aSelector	"returns the old one"	<primitive: 'primitiveSetExtraWordSelector' module: 'RVMPlugin'>	^self primitiveFailed! !!RVMPrimitives class methodsFor: 'testing' stamp: 'dmu 6/14/2010 15:36'!isRVM	"RVMPrimitives isRVM"	^ (self getCoreOf: nil) ~= -1! !!BlockClosure methodsFor: 'evaluating' stamp: 'dmu 6/14/2010 16:13'!valueAt: blockPriority 	"Evaluate the receiver (block), with another priority as the actual one 	and restore it afterwards. The caller should be careful with using 	higher priorities."	| activeProcess result outsidePriority |	activeProcess := Processor thisProcess.	outsidePriority := activeProcess priority.	activeProcess priority: blockPriority.	result := self ensure: [activeProcess priority: outsidePriority].	"Yield after restoring lower priority to give the preempted processes a  	chance to run."	blockPriority > outsidePriority		ifTrue: [Processor yield].	^ result! !!BlockClosure methodsFor: 'evaluating' stamp: 'dmu 6/14/2010 16:13'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor thisProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BlockClosure methodsFor: 'private' stamp: 'dmu 6/14/2010 16:13'!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess := Processor thisProcess.	oldPriority := activeProcess priority.	activeProcess priority: Processor highestPriority.	result := self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!BlockContext methodsFor: 'evaluating' stamp: 'dmu 6/14/2010 16:14'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor thisProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 6/14/2010 16:14'!valueAt: blockPriority 	"Evaluate the receiver (block), with another priority as the actual one 	and restore it afterwards. The caller should be careful with using 	higher priorities."	| activeProcess result outsidePriority |	activeProcess := Processor thisProcess.	outsidePriority := activeProcess priority.	activeProcess priority: blockPriority.	result := self				ensure: [activeProcess priority: outsidePriority].	"Yield after restoring lower priority to give the preempted processes a  	chance to run."	blockPriority > outsidePriority		ifTrue: [Processor yield].	^ result! !!BlockContext methodsFor: 'private' stamp: 'dmu 11/25/2008 00:18'!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess := Processor thisProcess.	oldPriority := activeProcess priority.	activeProcess priority: Processor highestPriority.	result := self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!CPUWatcher methodsFor: 'process operations' stamp: 'dmu 11/25/2008 00:18'!debugProcess: aProcess	| uiPriority oldPriority |	uiPriority := Processor thisProcess priority.	aProcess priority >= uiPriority ifTrue: [		oldPriority := ProcessBrowser setProcess: aProcess toPriority: uiPriority - 1	].	ProcessBrowser debugProcess: aProcess.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'dmu 6/14/2010 16:14'!withProgressDo: aBlock	| safetyFactor totals trialRect delta targetOwner |	Smalltalk isMorphic ifFalse: [^aBlock value].	formerProject := Project current.	formerWorld := World.	formerProcess := Processor thisProcess.	targetMorph		ifNil: [targetMorph := ProgressTargetRequestNotification signal].	targetMorph ifNil: [		trialRect := Rectangle center: Sensor cursorPoint extent: 80@80.		delta := trialRect amountToTranslateWithin: formerWorld bounds.		trialRect := trialRect translateBy: delta.		translucentMorph := TranslucentProgessMorph new			opaqueBackgroundColor: Color white;			bounds: trialRect;			openInWorld: formerWorld.	] ifNotNil: [		targetOwner := targetMorph owner.		translucentMorph := TranslucentProgessMorph new			setProperty: #morphicLayerNumber toValue: targetMorph morphicLayerNumber - 0.1;			bounds: targetMorph boundsInWorld;			openInWorld: targetMorph world.	].	stageCompleted := 0.	safetyFactor := 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	translucentMorph hide.	targetOwner ifNotNil: [targetOwner hide].	totals := self loadingHistoryDataForKey: 'total'.	newRatio := 1.0.	estimate := totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	start := Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note | | stageCompletedString |		translucentMorph show.		targetOwner ifNotNil: [targetOwner show].		note extraParam ifNotNil:[self addProgressDecoration: note extraParam].		stageCompletedString := (note messageText findTokens: ' ') first.		stageCompleted := (stageCompletedString copyUpTo: $:) asNumber.		cumulativeStageTime := Time millisecondClockValue - start max: 1.		prevData := self loadingHistoryDataForKey: stageCompletedString.		prevData isEmpty ifFalse: [			newRatio := (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self 			loadingHistoryAt: stageCompletedString 			add: cumulativeStageTime.		translucentMorph 			setProperty: #progressStageNumber 			toValue: stageCompleted + 1.		note resume.	].	stageCompleted := 999.	"we may or may not get here"! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:19'!inActiveControllerProcess	"Answer whether the active scheduling process is the actual active 	process in the system."	^activeControllerProcess == Processor thisProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:19'!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController := nil.	activeControllerProcess := Processor thisProcess.! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:20'!scheduleActiveNoTerminate: aController 	"Make aController be the active controller. Presumably the process that 	requested the new active controller wants to keep control to do more 	activites before the new controller can take control. Therefore, do not 	terminate the currently active process."	self schedulePassive: aController.	self scheduled: aController		from: Processor thisProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:20'!searchForActiveController	"Find a scheduled controller that wants control and give control to it. If 	none wants control, then see if the System Menu has been requested."	| aController |	activeController := nil.	activeControllerProcess := Processor thisProcess.	self activeController: self nextActiveController.	Processor terminateActive! !!Cursor methodsFor: 'displaying' stamp: 'dmu 6/14/2010 16:15'!showWhile: aBlock 	"While evaluating the argument, aBlock, make the receiver be the cursor shape."	"ar 2/2/2006: Only allow this if active process is ui process"	| oldcursor |	Processor thisProcess == Project uiProcess ifFalse:[^aBlock value].	oldcursor := Sensor currentCursor.	self show.	^aBlock ensure: [oldcursor show]! !!Debugger class methodsFor: 'class initialization' stamp: 'dmu 6/14/2010 16:15'!openContext: aContext label: aString contents: contentsStringOrNil	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion := false.		self primitiveError: aString].	ErrorRecursion := true.	self informExistingDebugger: aContext label: aString.	(Debugger context: aContext)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion := false.	Processor thisProcess suspend.! !!Debugger class methodsFor: 'instance creation' stamp: 'dmu 6/14/2010 16:15'!context: aContext	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor thisProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!DelayWaitTimeout methodsFor: 'private' stamp: 'dmu 6/14/2010 16:15'!setDelay: anInteger forSemaphore: aSemaphore	super setDelay: anInteger forSemaphore: aSemaphore.	process := Processor thisProcess.	expired := false.! !!HTTPLoader methodsFor: 'private' stamp: 'dmu 6/14/2010 16:15'!startDownload	| newDownloadProcess |		downloads size >= self maxNrOfConnections ifTrue: [^self].	requests size <= 0 ifTrue: [^self].	newDownloadProcess := [		[			self nextRequest startRetrieval		] on: FTPConnectionException do: [ :ex | 			Cursor normal show.			self removeProcess: Processor thisProcess.			self startDownload		].		self removeProcess: Processor thisProcess.		self startDownload	] newProcess.	downloads add: newDownloadProcess.	newDownloadProcess resume! !!MVCToolBuilder class methodsFor: 'accessing' stamp: 'dmu 6/14/2010 16:16'!isActiveBuilder	"Answer whether I am the currently active builder"	"This is really a way of answering whether 'Smalltalk isMVC'"	ScheduledControllers ifNil:[^false].	^ScheduledControllers activeControllerProcess == Processor thisProcess! !!MVCUIManager class methodsFor: 'accessing' stamp: 'dmu 6/14/2010 16:16'!isActiveManager	"Answer whether I should act as the active ui manager"	"This is really a way of answering whether 'Smalltalk isMVC'"	ScheduledControllers ifNil:[^false].	^ScheduledControllers activeControllerProcess == Processor thisProcess! !!MessageTally methodsFor: 'initialize-release' stamp: 'dmu 6/14/2010 16:16'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor thisProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[ true ] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		time := Time millisecondClockValue - time0]! !!Monitor methodsFor: 'private' stamp: 'dmu 6/14/2010 16:16'!enter	self isOwnerProcess ifTrue: [		nestingLevel := nestingLevel + 1.	] ifFalse: [		mutex wait.		ownerProcess := Processor thisProcess.		nestingLevel := 1.	].! !!Monitor methodsFor: 'private' stamp: 'dmu 6/14/2010 16:16'!isOwnerProcess	^ Processor thisProcess == ownerProcess! !!Paragraph methodsFor: 'RVM' stamp: 'dmu 6/15/2010 11:36'!destFormSema: s	destFormSema := s! !!Paragraph methodsFor: 'private' stamp: 'dmu 4/1/2009 19:38'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle := compositionRect copy.	text := aText.	textStyle := aTextStyle.	rule := DefaultRule.	mask := nil.		"was DefaultMask "	marginTabsLevel := 0.	destFormSema := Semaphore forMutualExclusion.	destinationForm := Display.	offset := aPoint.	^self composeAll! !!Paragraph methodsFor: 'private' stamp: 'ssa 4/7/2009 12:39'!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	destFormSema isNil ifTrue:[self destFormSema: Semaphore forMutualExclusion].	destFormSema critical: [		saveDestinationForm := destinationForm.		self destinationForm: aDisplayMedium.		self displayLines: lineInterval.		destinationForm := saveDestinationForm	]! !!PluggableTextMorphPlus methodsFor: 'styling' stamp: 'dmu 6/21/2010 15:35'!hasUnacceptedEdits: aBoolean	"re-implemented to re-style the text iff aBoolean is true"	 	self textInterlock critical: [		super hasUnacceptedEdits: aBoolean].	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess: textMorph contents]! !!PluggableTextMorphPlus methodsFor: 'styling' stamp: 'dmu 6/21/2010 15:33'!setText: aText	self okToStyle ifFalse:[^super setText: aText].	self textInterlock critical: [		super setText: (styler format: aText asText).	].	aText size < 4096		ifTrue:[styler style: textMorph contents]		ifFalse:[styler styleInBackgroundProcess:  textMorph contents]! !!PluggableTextMorphPlus methodsFor: 'RVM' stamp: 'dmu 6/21/2010 11:33'!textInterlock	textInterlock isNil		ifTrue: [textInterlock := Monitor new].	^textInterlock! !!Process methodsFor: 'accessing' stamp: 'ssa 2/17/2009 22:34'!isActiveProcess	^ Processor areRunningProcessesInSchedulerLists		ifTrue: [ suspendedContext isNil and:[myList notNil]]		ifFalse: [self == Processor activeProcess]! !!Process methodsFor: 'accessing' stamp: 'dmu 6/18/2010 17:35'!isTerminated	self isActiveProcess ifTrue: [^ false].	^suspendedContext isNil	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.		   If so, and the pc is greater than the startpc, the bock has alrteady sent and returned		   from value and there is nothing more to do."		suspendedContext isBottomContext		and: [suspendedContext pc isNil or: [suspendedContext pc > suspendedContext startpc]]]! !!Process methodsFor: 'changing process state' stamp: 'dmu 6/14/2010 16:16'!run	"Suspend current process and execute self instead"	| proc |	proc := Processor thisProcess.	[	proc suspend.		self resume.	] forkAt: Processor highestPriority! !!Process methodsFor: 'changing process state' stamp: 'dmu 6/18/2010 00:18'!suspend	"Primitive. Stop the process that the receiver represents in such a way 	that it can be restarted at a later time (by sending the receiver the 	message resume). If the receiver represents the activeProcess, suspend it. 	Otherwise remove the receiver from the list of waiting processes.	The return value of this method is the list the receiver was previously on (if any)."	| oldList |	<primitive: 88>	"This is fallback code for VMs which only support the old primitiveSuspend which 	would not accept processes that are waiting to be run."	RVMPrimitives isRVM ifTrue: [self error: 'suspend should never fail'].	myList ifNil:[^nil]. "this allows us to use suspend multiple times"	oldList := myList.	myList := nil.	oldList remove: self ifAbsent:[].	^oldList! !!Process methodsFor: 'changing process state' stamp: 'dmu 6/17/2010 23:57'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock oldList |	self == Processor thisProcess  ifTrue: [ 		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			(ctxt tempAt: 2) ifNil:[				ctxt tempAt: 2 put: nil.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self suspend.	] ifFalse:[		"Always suspend the process first so it doesn't accidentally get woken up"		oldList := self suspend.		suspendedContext ifNotNil:[			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(oldList class == Semaphore and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			"If we are terminating a process halfways through an unwind, try			to complete that unwind block first."			(suspendedContext findNextUnwindContextUpTo: nil) ifNotNil:[:outer|				(suspendedContext findContextSuchThat:[:c| c closure == (outer tempAt: 1)]) ifNotNil:[:inner|					"This is an unwind block currently under evaluation"					suspendedContext runUntilErrorOrReturnFrom: inner.				].			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:05'!activateReturn: aContext value: value	"Activate 'aContext return: value', so execution will return to aContext's sender"	self suspend.	^ suspendedContext := suspendedContext activateReturn: aContext value: value! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:01'!complete: aContext 	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."		| ctxt pair error |	self suspend.	ctxt := suspendedContext.	suspendedContext := nil.  "disable this process while running its stack in active process below"	pair := ctxt runUntilErrorOrReturnFrom: aContext.	suspendedContext := pair first.	error := pair second.	error ifNotNil: [^ error signalerContext].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 6/14/2010 16:06'!install: aContext 	"Replace the suspendedContext with aContext."	(Processor isActive: self)		ifTrue: [^self error: 'An active process cannot install contexts'].	suspendedContext := aContext! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 6/14/2010 16:07'!popTo: aContext 	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."	| callee |	(Processor isActive: self)		ifTrue: [^ self error: 'An active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ aContext].  "aContext is on top"	^ self return: callee value: callee receiver! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 6/14/2010 16:08'!popTo: aContext value: aValue	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	| callee |	(Processor isActive: self)		ifTrue: [^ self error: 'An active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ self].  "aContext is on top"	self return: callee value: aValue! !!Process class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 15:11'!semaForSuspensions	SemaForSuspensions isNil ifTrue:[SemaForSuspensions := Semaphore forMutualExclusion].	^SemaForSuspensions! !!Process methodsFor: 'debugging' stamp: 'dmu 6/14/2010 16:09'!debug: context title: title full: bool	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt :=  self == Processor thisProcess  ifTrue: [thisContext]		ifFalse: [			self suspend.  			self suspendedContextWaitingIfNecessary].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].	ToolSet debug: self context: context label: title contents: nil fullView: bool.! !!Process methodsFor: 'debugging' stamp: 'dmu 9/17/2010 12:03'!debugWithTitle: title	"Open debugger on self"	| context |	context := self == Processor thisProcess  ifTrue: [thisContext] ifFalse: [ self suspend.  self suspendedContextWaitingIfNecessary].	self debug: context title: title full: true.! !!Process methodsFor: 'signaling' stamp: 'ssa 2/17/2009 22:31'!pvtSignal: anException list: aList	"Private. This method is used to signal an exception from another	process...the receiver must be the active process.  If the receiver 	was previously waiting on a Semaphore, then return the process	to the waiting state after signaling the exception and if the Semaphore	has not been signaled in the interim"	"Since this method is not called in a normal way, we need to take care	that it doesn't directly return to the caller (because I believe that could	have the potential to push an unwanted object on the caller's stack)."	| blocker |	self == Processor thisProcess ifFalse: [^self].	self suspend.	anException signal.	blocker := Semaphore new.	[self suspend.	suspendedContext := suspendedContext swapSender: nil.	aList class == Semaphore 		ifTrue:			[aList isSignaled				ifTrue: 					[aList wait.  "Consume the signal that would have restarted the receiver"					self resume]				ifFalse:					["Add us back to the Semaphore's list (and remain blocked)"					myList := aList.					aList add: self]]		ifFalse: [self resume]] fork.	blocker wait.! !!Process methodsFor: 'signaling' stamp: 'dmu 6/14/2010 16:11'!signalException: anException	"Signal an exception in the receiver process...if the receiver is currently	suspended, the exception will get signaled when the receiver is resumed.  If 	the receiver is blocked on a Semaphore, it will be immediately re-awakened	and the exception will be signaled; if the exception is resumed, then the receiver	will return to a blocked state unless the blocking Semaphore has excess signals"	| oldList |	"If we are the active process, go ahead and signal the exception"	self == Processor thisProcess  ifTrue: [^anException signal].	"Suspend myself first to ensure that I won't run away in the	midst of the following modifications."	myList ifNotNil:[oldList := self suspend].	"Add a new method context to the stack that will signal the exception"	suspendedContext := MethodContext		sender: suspendedContext		receiver: self		method: (self class lookupSelector: #pvtSignal:list:)		arguments: (Array with: anException with: oldList).	"If we are on a list to run, then suspend and restart the receiver 	(this lets the receiver run if it is currently blocked on a semaphore).  If	we are not on a list to be run (i.e. this process is suspended), then when the	process is resumed, it will signal the exception"	oldList ifNotNil: [self resume].! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:40'!coreMask	^ coreMask! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:40'!coreMask: m	coreMask := m! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:41'!hostCore	^ hostCore! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:31'!isRunning	Processor thisProcess == self ifTrue: [^ true].	self isActiveProcess ifTrue: [^ true].	myList ifNil: [^ false].	^ myList class ~~ Semaphore! !!Process methodsFor: 'RVM' stamp: 'ssa 3/2/2010 18:23'!nilMyListUnlessRVM	Processor areRunningProcessesInSchedulerLists ifFalse: [		"primitiveSuspend will use myList to remove from list and will nil it out"		myList := nil.	]! !!ProcessBrowser methodsFor: 'stack list' stamp: 'dmu 6/14/2010 16:17'!updateStackList: depth 	| suspendedContext oldHighlight |	selectedProcess		ifNil: [^ self changeStackListTo: nil].	(stackList notNil and: [ stackListIndex > 0 ])		ifTrue: [oldHighlight := stackList at: stackListIndex].	selectedProcess == Processor thisProcess		ifTrue: [self				changeStackListTo: (thisContext stackOfSize: depth)]		ifFalse: [suspendedContext := selectedProcess suspendedContext.			suspendedContext				ifNil: [self changeStackListTo: nil]				ifNotNil: [self						changeStackListTo: (suspendedContext stackOfSize: depth)]].	self		stackListIndex: (stackList				ifNil: [0]				ifNotNil: [stackList indexOf: oldHighlight])! !!ProcessBrowser class methodsFor: 'class initialization' stamp: 'dmu 6/14/2010 16:17'!registerWellKnownProcesses	"Associate each well-known process with a nickname and two flags: allow-stop, and allow-debug.	Additional processes may be added to this list as required"	WellKnownProcesses := OrderedCollection new.	self registerWellKnownProcess: []		label: 'no process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Smalltalk lowSpaceWatcherProcess]		label: 'the low space watcher'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [WeakArray runningFinalizationProcess]		label: 'the WeakArray finalization process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Processor thisProcess]		label: 'the UI process'		allowStop: false		allowDebug: true.	self registerWellKnownProcess: [Processor backgroundProcess]		label: 'the idle process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Sensor interruptWatcherProcess]		label: 'the user interrupt watcher'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Sensor eventTicklerProcess]		label: 'the event tickler'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Project uiProcess]		label: 'the inactive Morphic UI process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess:			[Smalltalk at: #SoundPlayer ifPresent: [:sp | sp playerProcess]]		label: 'the Sound Player'		allowStop: false		allowDebug: false.	self registerWellKnownProcess:			[ScheduledControllers ifNotNil: [ScheduledControllers activeControllerProcess]]		label: 'the inactive MVC controller process'		allowStop: false		allowDebug: true.	self registerWellKnownProcess:			[Smalltalk at: #CPUWatcher ifPresent: [:cw | cw currentWatcherProcess]]		label: 'the CPUWatcher'		allowStop: false		allowDebug: false! !!SHTextStyler methodsFor: 'styling' stamp: 'sm 9/29/2010 18:27'!initialize	stylingEnabled := true.	"If on RVM deactivate it for the moment. There is a racecondition we do not handle yet."		RVMPrimitives isRVM ifTrue: [ stylingEnabled := false ]! !!SHTextStyler methodsFor: 'styling' stamp: 'dmu 6/21/2010 15:34'!styleInBackgroundProcess: aText	self terminateBackgroundStylingProcess.	stylingEnabled ifTrue:[		text := aText copy.		self monitor critical: [			sem := Semaphore new. 			[sem notNil				ifTrue: [					sem wait.					view ifNotNil: [ self textInterlock critical: [view stylerStyledInBackground: text]]]			] forkAt: Processor activePriority.			backgroundProcess := 				[ | s |				self privateStyle: text.				s := sem. "terminateBackgroundStylingProcess nils sem"				s ifNotNil: [s signal]]					forkAt: Processor userBackgroundPriority] ]	! !!SHTextStyler methodsFor: 'RVM' stamp: 'dmu 6/21/2010 11:34'!textInterlock	view isNil		ifTrue: [^ Monitor new].	^view textInterlock! !!SoundPlayer class methodsFor: 'player process' stamp: 'dmu 6/14/2010 16:17'!stopPlayerProcess	"Stop the sound player process."	"SoundPlayer stopPlayerProcess"	(PlayerProcess == nil or:[PlayerProcess == Processor thisProcess]) 		ifFalse:[PlayerProcess terminate].	PlayerProcess := nil.	self primSoundStop.	ActiveSounds := OrderedCollection new.	Buffer := nil.	PlayerSemaphore := Semaphore forMutualExclusion.	ReadyForBuffer ifNotNil:		[Smalltalk unregisterExternalObject: ReadyForBuffer].	ReadyForBuffer := nil.! !!StandardToolSet class methodsFor: 'debugging' stamp: 'dmu 6/14/2010 16:17'!debugError: anError	"Handle an otherwise unhandled error"	^Processor thisProcess		debug: anError signalerContext		title: anError description! !!SyntaxError class methodsFor: '*Morphic-Support' stamp: 'dmu 6/14/2010 16:19'!morphicOpen: aSyntaxError	"Answer a view whose model is an instance of me."	self buildMorphicViewOn: aSyntaxError.	Project spawnNewProcessIfThisIsUI: Processor thisProcess.	^ Processor thisProcess suspend! !!SyntaxError class methodsFor: '*ST80-Support' stamp: 'dmu 6/14/2010 16:18'!mvcOpen: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	topView := self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor thisProcess suspend! !!TestCase methodsFor: 'extensions' stamp: 'dmu 6/14/2010 16:18'!should: aBlock notTakeMoreThan: aDuration    "Evaluate aBlock in a forked process and if it takes more than anInteger milliseconds    to run we terminate the process and report a test failure.  It'' important to    use the active process for the test failure so that the failure reporting works correctly    in the context of the exception handlers."    | evaluated evaluationProcess result delay testProcess |    evaluated := false.    delay := Delay forDuration: aDuration.    testProcess := Processor thisProcess.    "Create a new process to evaluate aBlock"    evaluationProcess := [        result := aBlock value.        evaluated := true.        delay unschedule.        testProcess resume ] forkNamed: 'Process to evaluate should: notTakeMoreThanMilliseconds:'.    "Wait the milliseconds they asked me to"    delay wait.    "After this point either aBlock was evaluated or not..."    evaluated ifFalse: [        evaluationProcess terminate.        self assert: false description: ('Block evaluation took more than the expected <1p>' expandMacrosWith: aDuration)].       ^result! !!SemaphoreTest methodsFor: 'private' stamp: 'dmu 6/14/2010 16:17'!criticalError	Processor thisProcess terminate! !!TestFailure methodsFor: 'camp smalltalk' stamp: 'dmu 6/14/2010 16:18'!defaultAction	Processor thisProcess		debug: self signalerContext		title: self description! !!Utilities class methodsFor: 'fetching updates' stamp: 'dmu 6/14/2010 16:19'!retrieveUrls: urls ontoQueue: queue withWaitSema: waitSema 	"download the given list of URLs. The queue will be loaded alternately  	with url's and with the retrieved contents. If a download fails, the  	contents will be #failed. If all goes well, a special pair with an empty  	URL and the contents #finished will be put on the queue. waitSema is  	waited on every time before a new document is downloaded; this keeps 	the downloader from getting too far  ahead of the main process"	"kill the existing downloader if there is one"	| updateCounter |	UpdateDownloader		ifNotNil: [UpdateDownloader terminate].	updateCounter := 0.	"fork a new downloading process"	UpdateDownloader := [		'Downloading updates' displayProgressAt: Sensor cursorPoint from: 0 to: urls size during: [:bar |			urls				do: [:url | | front canPeek doc | 					waitSema wait.					queue nextPut: url.					doc := HTTPClient httpGet: url.					doc isString						ifTrue: [queue nextPut: #failed.							UpdateDownloader := nil.							Processor thisProcess terminate]						ifFalse: [canPeek := 120 min: doc size.							front := doc next: canPeek.  doc skip: -1 * canPeek.							(front beginsWith: '<!!DOCTYPE') ifTrue: [								(front includesSubString: 'Not Found') ifTrue: [									queue nextPut: #failed.									UpdateDownloader := nil.									Processor thisProcess terminate]]].						UpdateDownloader ifNotNil: [queue nextPut: doc. updateCounter := updateCounter + 1. bar value: updateCounter]]].			queue nextPut: ''.			queue nextPut: #finished.			UpdateDownloader := nil] newProcess.	UpdateDownloader priority: Processor userInterruptPriority.	"start the process running"	UpdateDownloader resume! !!Paragraph reorganize!('accessing' backgroundColor clippingRectangle clippingRectangle: compositionRectangle compositionRectangle: destinationForm fillColor fillColor: height indentationOfLineIndex:ifBlank: mask numberOfLines replaceFrom:to:with:displaying: rule rule: stringAtLineNumber: text:)('alignment' centered justified leftFlush rightFlush toggleAlignment)('character location' characterBlockAtPoint: characterBlockForIndex: defaultCharacterBlock)('composition' composeAll wrappingBox:clippingBox:)('converting' asForm asString asText)('display box access' boundingBox computeBoundingBox)('displaying' displayOn: displayOn:at: displayOn:at:clippingBox:rule:fillColor: displayOn:transformation:clippingBox:align:with:rule:fillColor:)('indicating' flash outline)('scrolling' scrollBy: scrollBy:withSelectionFrom:to: scrollDelta scrollUncheckedBy:withSelectionFrom:to:)('selecting' caretFormForDepth: clickAt:for:controller: extendSelectionAt:endBlock: extendSelectionMark:pointBlock: hiliteRect: mouseMovedFrom:pivotBlock:showingCaret: mouseSelect mouseSelect: reverseFrom:to: selectionRectsFrom:to:)('utilities' clearVisibleRectangle deepCopy destinationForm: fit lines: visibleRectangle)('RVM' destFormSema:)('private' bottomAtLineIndex: compositionRectangle:text:style:offset: compositionRectangleDelta displayLines: displayLines:affectedRectangle: displayOn:lines: leftMarginForCompositionForLine: leftMarginForDisplayForLine:alignment: lineAt:put: lineIndexOfCharacterIndex: lineIndexOfTop: lines moveBy: rightMarginForComposition rightMarginForDisplay setWithText:style: setWithText:style:compositionRectangle:clippingRectangle: setWithText:style:compositionRectangle:clippingRectangle:foreColor:backColor: topAtLineIndex: topAtLineIndex:using:and: trimLinesTo: updateCompositionHeight withClippingRectangle:do:)!!BitBlt methodsFor: 'accessing' stamp: 'dmu 4/4/2009 00:24'!copyBitsOnMain	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap := colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX := destX asInteger.	destY := destY asInteger.	width := width asInteger.	height := height asInteger.	sourceX := sourceX asInteger.	sourceY := sourceY asInteger.	clipX := clipX asInteger.	clipY := clipY asInteger.	clipWidth := clipWidth asInteger.	clipHeight := clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'dmu 4/4/2009 00:20'!copyBitsLocally	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBitsLocally'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap := colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX := destX asInteger.	destY := destY asInteger.	width := width asInteger.	height := height asInteger.	sourceX := sourceX asInteger.	sourceY := sourceY asInteger.	clipX := clipX asInteger.	clipY := clipY asInteger.	clipWidth := clipWidth asInteger.	clipHeight := clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/3/2009 23:01'!drawLoopLocallyX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| |	<primitive: 'primitiveDrawLoopLocally'>self primitiveFailed! !!BitBlt methodsFor: 'line drawing' stamp: 'ssa 4/3/2009 22:36'!globalDrawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>	dx := xDelta sign.	dy := yDelta sign.	px := yDelta abs.	py := xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P := py // 2.			1 to: py do: 				[:i |				destX := destX + dx.				(P := P - px) < 0 ifTrue: 						[destY := destY + dy.						P := P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P := px // 2.			1 to: px do:				[:i |				destY := destY + dy.				(P := P - py) < 0 ifTrue: 						[destX := destX + dx.						P := P + px].				i < px ifTrue: [self copyBits]]]! !!BitBlt methodsFor: 'line drawing' stamp: 'ssa 4/3/2009 22:52'!localDrawLoopX: xDelta Y: yDelta 	"Primitive"	<primitive: 'primitiveDrawLoopLocally'>	^self primitiveFailed! !!ControlManager methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:14'!activeControllerNoTerminate: aController andProcess: aProcess	"Set aController to be the currently active controller and aProcess to be 	the process that handles controller scheduling activities in the 	system. This message differs from activeController:andProcess: in that it 	does not send controlTerminate to the currently active controller."	self inActiveControllerProcess		ifTrue: 			[aController~~nil				ifTrue: [(scheduledControllers includes: aController)							ifTrue: [self promote: aController]							ifFalse: [self error: 'Old controller not scheduled']].			activeController := aController.			activeController == nil				ifFalse: [activeController controlInitialize].			activeControllerProcess := aProcess.			activeControllerProcess resume]		ifFalse: 			['New active controller process must be set from old one, resetting...' print.			self reset.			] ! !!ControlManager methodsFor: 'scheduling' stamp: 'ssa 3/2/2010 14:12'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList := activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor thisProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController :=		(Debugger			openInterrupt: labelString 			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ssa 3/25/2010 16:17'!reset	"ssa - reset the window controller process"	| newProcess |	newProcess := [ScheduledControllers resetActiveController.			ScheduledControllers searchForActiveController] fixTemps newProcess priority: Processor userSchedulingPriority.	newProcess resume.	"lose the current process"	"Processor terminateActive"! !!Controller methodsFor: 'basic control sequence' stamp: 'dmu 3/22/2010 14:25'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	[RVMPrimitives isRVM ifTrue: [Processor yield. ^ self].].	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime := Time millisecondClockValue.			wait := lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait <= MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							"(Delay forMilliseconds: wait) wait "]. ]. ]. ].	lastActivityTime := Time millisecondClockValue.! !!EventSensor methodsFor: 'private' stamp: 'ssa 12/17/2009 14:18'!flushNonKbdEvents	eventQueue ifNil: [^ self].	[^self]value.   "don't flush so we don't lose events"	eventQueue flushAllSuchThat:		[:buf | (self isKbdEvent: buf) not]! !!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26'!primMouseButtons	self fetchMoreEvents.	self flushNonKbdEvents.	^ mouseButtons! !!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26'!primMousePt	self fetchMoreEvents.	self flushNonKbdEvents.	^ mousePosition! !!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/17/2009 12:46'!processEvent: evt 	"Process a single event. This method is run at high priority."	| type |	type := evt at: 1.	"Tackle mouse events first"	type = EventTypeMouse		ifTrue: [evt				at: 5				put: (ButtonDecodeTable at: (evt at: 5)							+ 1). 				self queueEvent: evt.				self processMouseEvent: evt . 				^self].		"Store the event in the queue if there's any"	type = EventTypeKeyboard		ifTrue: [ "Check if the event is a user interrupt"			((evt at: 4) = 0				and: [((evt at: 3)						bitOr: (((evt at: 5)							bitAnd: 8)							bitShift: 8))							= interruptKey])					ifTrue: ["interrupt key is meta - not reported as event"							^ interruptSemaphore signal].			"Else swap ctrl/alt keys if neeeded.wi"			KeyDecodeTable				at: {evt at: 3. evt at: 5}				ifPresent: [:a | evt at: 3 put: a first;						 at: 5 put: a second]. 			self queueEvent: evt. 			self processKeyboardEvent: evt . 			^self ].					"Handle all events other than Keyborad or Mouse."	self queueEvent: evt.	! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:38'!forkOn: aCore	"Create and schedule a Process running the code in the receiver."	^ self newProcess resumeOn: aCore! !!BlockContext methodsFor: 'scheduling' stamp: 'ssa 4/8/2009 20:09'!forkOn: aCore with: anObject	"Create and schedule a Process running the code in the receiver."	^ (self newProcessWith: anObject) resumeOn: aCore! !!BlockContext methodsFor: 'scheduling' stamp: 'ssa 4/8/2009 20:08'!forkOn: aCore with: anObject at: aPriority	"Create and schedule a Process running the code in the receiver."	| proc |	proc := self newProcessWith: anObject.	proc priority: aPriority.	^proc resumeOn: aCore! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:34'!forkWith: anObject	"Create and schedule a Process running the code in the receiver."	^ (self newProcessWith: anObject) resume! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:33'!newProcessWith: anObject	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value: anObject.			Processor terminateActive]		priority: Processor activePriority! !!Delay class methodsFor: 'snapshotting' stamp: 'dmu 5/25/2010 11:02'!startUp	"Restart active delay, if any, when resuming a snapshot."	DelaySuspended ifFalse:[^self error: 'Trying to activate Delay twice'].	DelaySuspended := false.	self restoreResumptionTimes.	ActiveDelay == nil ifFalse: [ActiveDelay activate].	AccessProtect := Semaphore forMutualExclusion! !!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!hostCore: anObject	"Set the value of hostCore"	hostCore := anObject! !!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!myList	"Answer the value of myList"	myList isNil ifTrue:[self myList: nil].	^ myList! !!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!myList: anObject	"Set the value of myList"	myList := anObject! !!Process methodsFor: 'changing process state' stamp: 'dmu 3/2/2010 17:02'!primitiveSuspend	"Primitive. Stop the process that self represents in such a way 	that it can be restarted at a later time (by sending #resume).	ASSUMES self is the active process.	Essential. See Object documentation whatIsAPrimitive."	"Debugging code below causes terminated running processes to seem not terminated. -- dmu 3/2/10"	"(myList isNil and: [RVMPrimitives isRVM]) ifTrue:[self halt]."	<primitive: 88>	self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'dmu 4/7/2009 02:41'!resumeOn: aCore  self useOnlyCore: aCore.  self resume! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:04'!return: aContext value: value	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."        self suspend.	suspendedContext == aContext ifTrue: [		^ suspendedContext := aContext return: value from: aContext].	self activateReturn: aContext value: value.	^ self complete: aContext.! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:03'!step         self suspend.	^ suspendedContext := suspendedContext step! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:04'!stepToCallee	"Step until top context changes"	| ctxt |	self suspend.	ctxt := suspendedContext.	[ctxt == suspendedContext] whileTrue: [		suspendedContext := suspendedContext step].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:05'!stepToSendOrReturnself suspend.	^ suspendedContext := suspendedContext stepToSendOrReturn! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 02:57'!avoidCore: anIndex	"Force this process to avoid this core (0-55)"	self coreMask: (self coreMask bitClear: (1 bitShift: anIndex))! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 03:49'!avoidCores: aCollectionOfIndicies	"Force this process to avoid these cores (0-55)"	| mask |	mask := 0.	aCollectionOfIndicies do:[:index| mask := mask bitOr: (1 bitShift: index)].	self coreMask: (self coreMask bitClear:mask)! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 02:59'!useAdditionalCore: anIndex	"Force this process to only urn on this core (0-55)"	self coreMask: (self coreMask bitOr:(1 bitShift: anIndex))! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 03:50'!useAdditionalCores: aCollectionOfIndicies	"Allow this process to run on these additional cores (0-55)"	| mask |	mask := 0.	aCollectionOfIndicies do:[:index| mask := mask bitOr: (1 bitShift: index)].	self coreMask: (self coreMask bitOr:mask)! !!Process methodsFor: 'core assignment' stamp: 'dmu 5/5/2009 01:32'!useOnlyCore: anIndex	"Force this process to only run on this core (0-55)"	self coreMask: (1 bitShift: anIndex)! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 03:02'!useOnlyCores: aCollectionOfIndicies	"Force this process to only run on these cores (0-55)"	| mask |	mask := 0.	aCollectionOfIndicies do:[:index| mask := mask bitOr: (1 bitShift: index)].	self coreMask: mask! !!Process methodsFor: 'core assignment' stamp: 'dmu 1/25/2010 11:06'!useOnlyMainCore	RVMPrimitives isRVM ifTrue: [self useOnlyCore: (RVMPrimitives getMainRank)]! !!Process methodsFor: 'signaling' stamp: 'ssa 2/17/2009 22:30'!signal: anException	"Signal an exception in the receiver process...if the receiver is currently	suspended, the exception will get signaled when the receiver is resumed.  If 	the receiver is blocked on a Semaphore, it will be immediately re-awakened	and the exception will be signaled; if the exception is resumed, then the receiver	will return to a blocked state unless the blocking Semaphore has excess signals"	"If we are the active process, go ahead and signal the exception"	self == Processor thisProcess ifTrue: [^anException signal].        self suspend.	"Add a new method context to the stack that will signal the exception"	suspendedContext := MethodContext		sender: suspendedContext		receiver: self		method: (self class methodDict at: #pvtSignal:list:)		arguments: (Array with: anException with: myList).	"If we are on a list to run, then suspend and restart the receiver 	(this lets the receiver run if it is currently blocked on a semaphore).  If	we are not on a list to be run (i.e. this process is suspended), then when the	process is resumed, it will signal the exception"	myList ifNotNil: [self suspend; resume].! !!Process class methodsFor: 'instance creation' stamp: 'dmu 3/24/2010 15:46'!forContext: aContext priority: anInteger 	"Answer an instance of me that has suspended aContext at priority 	anInteger."	| newProcess |	newProcess := self new.	newProcess suspendedContext: aContext.	newProcess priority: anInteger.	[newProcess coreMask:(1 bitShift: 27)].	^newProcess! !!Process class methodsFor: 'instance creation' stamp: 'ssa 2/26/2009 02:45'!forContext: aContext priority: anInteger coreMask: anIntegerMask	"Answer an instance of me that has suspended aContext at priority 	anInteger using this coreMask."	| newProcess |	newProcess := self forContext: aContext priority: anInteger.	newProcess coreMask:anIntegerMask.	^newProcess! !!ProcessorScheduler methodsFor: 'removing' stamp: 'ssa 6/11/2010 14:37'!removeAllPossible	"Terminate and remove all processes that you can.	This should leave the standard set only"	self terminatableProcesses print do:[:proc| proc terminate]! !!ProcessorScheduler methodsFor: 'removing' stamp: 'ssa 6/11/2010 14:31'!terminatableProcesses	"Answer all current processes that may be user terminated like in the ProcessBrowser"	"self terminatableProcesses"	| processList |	Smalltalk garbageCollectMost. "lose defunct processes"	processList := Process allSubInstances				reject: [:each | each isTerminated].	processList := processList				sortBy: [:a :b | a priority >= b priority].	processList := WeakArray withAll: processList.	^processList select:[:proc| (ProcessBrowser nameAndRulesFor: proc) at: 2]! !!Project methodsFor: 'menu messages' stamp: 'dmu 11/25/2008 00:23'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject := self.	Display newDepthNoRestore: displayDepth.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	world isMorph		ifTrue:			["Entering a Morphic project"			World := world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World := nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess := Processor thisProcess.! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:07'!interlock	interlock ifNil: [self interlock: Semaphore forMutualExclusion].	^ interlock! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:07'!interlock: aSemaphore	interlock := aSemaphore! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:14'!resetInterlock	self interlock signal.	self interlock: nil! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:09'!safelyDo: aBlock	^ self interlock critical: aBlock! !!StandardFileStream class methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:14'!resetAllInterlocks	"self resetAllInterlocks"	self allSubInstancesDo: [:sfs| sfs resetInterlock]! !!RemoteString methodsFor: 'accessing' stamp: 'dmu 9/7/2010 17:19'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile theText |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile := SourceFiles at: sourceFileNumber.		theFile safelyDo: [		theFile position: filePositionHi.		theText := theFile nextChunkText].	^theText! !!SyntaxError class methodsFor: 'instance creation' stamp: 'dmu 11/25/2008 00:25'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"		topView := self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor thisProcess suspend.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'dmu 9/7/2010 14:26'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	Object flushDependents.	Object flushEvents.	save & (SourceFiles at: 2) notNil ifTrue:		[msg :=  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString, ' ', (FileDirectory default localNameFor: self imageName).		sourceLink := ' priorSource: ' , LastQuitLogPosition printString.		self assureStartupStampLogged.		(SourceFiles at: 2) safelyDo: [			LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position.			self logChange: msg , sourceLink.		].		Transcript cr; show: msg].	self processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming == true ifTrue: [self clearExternalObjects].	self processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self readDocumentFile].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!UnhandledError methodsFor: 'priv handling' stamp: 'dmu 11/25/2008 00:25'!devDefaultAction	Processor thisProcess		debug: exception signalerContext		title: exception description! !!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:42'!deEmphasizeLabel	"Un-Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self critical: [		self displayLabelBackground: false.		self displayLabelText.	]! !Cursor initialize!Controller initialize!!BitBlt methodsFor: 'copying' stamp: 'ssa 4/7/2009 13:44'!OLDcopyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap := colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX := destX asInteger.	destY := destY asInteger.	width := width asInteger.	height := height asInteger.	sourceX := sourceX asInteger.	sourceY := sourceY asInteger.	clipX := clipX asInteger.	clipY := clipY asInteger.	clipWidth := clipWidth asInteger.	clipHeight := clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'dmu 5/10/2009 08:43'!copyBits	RVMPrimitives isRVM ifFalse:[^self OLDcopyBits]. 	destForm == Display  ifTrue: [self copyBitsOnMain] ifFalse: [self copyBitsLocally]! !!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/10/2009 22:47'!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards := (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 := startPoint. point2 := stopPoint]		ifFalse: [point1 := stopPoint. point2 := startPoint].	sourceForm == nil ifTrue:		[destX := point1 x.		destY := point1 y]		ifFalse:		[width := sourceForm width.		height := sourceForm height.		offset := sourceForm offset.		destX := (point1 x + offset x) rounded.		destY := (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].		(destForm == Display or:[RVMPrimitives isRVM not]) ifTrue: [	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded]			ifFalse: [self drawLoopLocallyX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded].	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].! !!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/10/2009 22:47'!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."			^(destForm == Display  or:[RVMPrimitives isRVM not])			ifTrue:[self globalDrawLoopX:xDelta Y: yDelta ]			ifFalse:[self localDrawLoopX:xDelta Y: yDelta ]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'dmu 9/7/2010 14:17'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue:		[SystemChangeNotifier uniqueInstance classCommented: self.		^ self organization classComment: aString stamp: aStamp].	oldCommentRemoteStr := self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr := oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file := SourceFiles at: 2) ifNotNil: [		file safelyDo: [			file setToEnd; cr; nextPut: $!!.	"directly"			"Should be saying (file command: 'H3') for HTML, but ignoring it here"			header := String streamContents: [:strm | strm nextPutAll: self name;				nextPutAll: ' commentStamp: '.				aStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: ptr printString].			file nextChunkPut: header]]].	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.	SystemChangeNotifier uniqueInstance classCommented: self.! !!CompiledMethod methodsFor: 'source code management' stamp: 'dmu 9/7/2010 14:23'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString |	(SourceFiles == nil or: [(file := SourceFiles at: fileIndex) == nil]) ifTrue:		[^self become: (self copyWithTempsFromMethodNode: methodNode)].	SmalltalkImage current assureStartupStampLogged.		file safelyDo: [		file setToEnd.		preambleBlock value: file.  "Write the preamble"		remoteString := RemoteString newString: sourceStr onFileNumber: fileIndex toFile: file.		file nextChunkPut: ' '.		InMidstOfFileinNotification signal ifFalse: [file flush].		self checkOKToAdd: sourceStr size at: remoteString position.		self setSourcePosition: remoteString position inFile: fileIndex].! !!RemoteString methodsFor: 'private' stamp: 'dmu 9/7/2010 14:23'!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile := SourceFiles at: fileNumber.		theFile safelyDo: [			theFile setToEnd; cr.			self string: aString onFileNumber: fileNumber toFile: theFile]		]! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'dmu 9/7/2010 14:26'!writeRecentCharacters: nCharacters toFileNamed: aFilename	"Schedule an editable text view on the last n characters of changes."	| changes |	changes := SourceFiles at: 2.	changes safelyDo: [		changes setToEnd; skip: nCharacters negated.		(FileStream newFileNamed: aFilename) nextPutAll: (changes next: nCharacters); close; open; edit	]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'dmu 9/7/2010 14:25'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aString := aStringOrText asString.	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile := SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile safelyDo: [		changesFile setToEnd; cr; cr.		changesFile nextChunkPut: aString.			"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"		self forceChangesToDisk.	]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'dmu 9/7/2010 14:25'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile := SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile isReadOnly ifTrue:[^self].	changesFile safelyDo: [		changesFile setToEnd; cr; cr.		changesFile nextChunkPut: StartupStamp asString; cr.		StartupStamp := nil.		self forceChangesToDisk.	]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'dmu 9/7/2010 14:22'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble := self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble := ''].	method := self methodDict at: selector ifAbsent:		[outStream nextPutAll: selector; cr.		outStream tab; nextPutAll: '** ERROR!!  THIS SCRIPT IS MISSING ** ' translated; cr; cr.		outStream nextPutAll: '  '.		^ outStream].	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos := method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: method decompileString]		ifFalse:		[sourceFile := SourceFiles at: method fileIndex.		sourceFile safelyDo: [			preamble size > 0				ifTrue:    "Copy the preamble"					[outStream copyPreamble: preamble from: sourceFile at: oldPos]				ifFalse:					[sourceFile position: oldPos].			"Copy the method chunk"			newPos := outStream position.			outStream copyMethodChunkFrom: sourceFile.			sourceFile skipSeparators.      "The following chunk may have ]style["			sourceFile peek == $] ifTrue: [				outStream cr; copyMethodChunkFrom: sourceFile].						moveSource ifTrue:    "Set the new method source pointer"				[endPos := outStream position.				method checkOKToAdd: endPos - newPos at: newPos.				method setSourcePosition: newPos inFile: fileIndex]]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'dmu 9/7/2010 14:12'!install	"Replace SourceFiles by an instance of me with the standard sources and changes files.	This only works if SourceFiles is either an Array or an instance of this class"	"StandardSourceFileArray install"	StandardFileStream resetAllInterlocks.	SourceFiles := self new initialize! !!Process methodsFor: 'RVM' stamp: 'dmu 9/17/2010 11:59'!suspendedContextWaitingIfNecessary	"In RVM, can suspend some other running process, and so after sending suspend, suspendedContext may still be nil."		[self suspendedContext isNil] whileTrue.	^ self suspendedContext! !!ParagraphEditor methodsFor: 'do-its' stamp: 'dmu 9/17/2010 12:00'!debug: aCompiledMethod receiver: anObject in: evalContext	| selector guineaPig debugger context |	selector := evalContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:].	anObject class addSelectorSilently: selector withMethod: aCompiledMethod.	guineaPig := evalContext isNil		ifTrue: [[anObject DoIt] newProcess]		ifFalse: [[anObject DoItIn: evalContext] newProcess].	context := guineaPig suspendedContextWaitingIfNecessary.	debugger := Debugger new		process: guineaPig		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: context		isolationHead: nil.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod]		whileFalse: [debugger send].	anObject class basicRemoveSelector: selector! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:37'!displayInterlock	displayInterlock ifNil: [self displayInterlock: Mutex new].	^ displayInterlock! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:24'!displayInterlock: aSemaphore	displayInterlock := aSemaphore! !!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:31'!displayEmphasized	"Display with label highlighted to indicate that it is active."	self  critical: [		self displayDeEmphasized; emphasize.		isLabelComplemented := true	]! !!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:30'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	self  critical: [		(bitsValid and: [controller ~~ ScheduledControllers activeController])			ifTrue: [self lock.					windowBits displayAt: self windowOrigin]			ifFalse: [Display deferUpdates: true.					super display.					Display deferUpdates: false; forceToScreen: self windowBox.					CacheBits ifTrue: [self cacheBitsAsIs]]	]! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:37'!critical: aBlock	^self displayInterlock critical: aBlock! !!Mutex methodsFor: 'mutual exclusion' stamp: 'dmu 6/14/2010 16:16'!critical: aBlock	"Evaluate aBlock protected by the receiver."	| activeProcess |	activeProcess := Processor thisProcess.	activeProcess == owner ifTrue:[^aBlock value].	^semaphore critical:[		owner := activeProcess.		aBlock ensure:[owner := nil]].! !!Mutex commentStamp: 'dmu 9/17/2010 12:34'!A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.Brought in from Squeak 4.1 because we need it.Instance variables:	semaphore	<Semaphore>		The (primitive) semaphore used for synchronization.	owner		<Process>		The process owning the mutex.!!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:42'!emphasizeLabel	"Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self critical: [		self displayLabelBackground: true.		self displayLabelBoxes.		self displayLabelText.	]! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:47'!resetDisplayInterlock	self displayInterlock: nil! !!ControlManager methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:48'!restore 	"Clear the screen to gray and then redisplay all the scheduled views.  Try to be a bit intelligent about the view that wants control and not display it twice if possible."	scheduledControllers first view uncacheBits.  "assure refresh"	self unschedule: screenController; scheduleOnBottom: screenController.	screenController view window: Display boundingBox; displayDeEmphasized.	self scheduledWindowControllers reverseDo:		[:aController | aController view resetDisplayInterlock; displayDeEmphasized].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'dmu 9/17/2010 16:39'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: []			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] forkAt: Processor thisProcess priority + 1]]! !