'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 8 October 2008 at 1:15:56 pm'!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.!----SNAPSHOT----#(8 October 2008 1:16:19 pm) minimal-MVC.image priorSource: 0!----SNAPSHOT----#(8 October 2008 1:16:38 pm) minimal-MVC.image priorSource: 176!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. !Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size.  35 1SystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size.!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. 35  35 1SystemNavigation new browseObsoleteReferences.!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. 35  35 1SystemNavigation new browseObsoleteReferences.Smalltalk garbageCollectUndeclared!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses!flushObsoleteSubclasses	"Behavior flushObsoleteSubclasses!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. !Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclasses!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclasses!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. !flushObsoleteSubclasses	"Behavior flushObsoleteSubclasses"	ObsoleteSubclasses!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.!self who!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. Behavior flushObsoleteSubclassesSystemNavigation new browseObsoleteReferences.Smalltalk garbageCollect!Smalltalk preMajorShrink.Smalltalk majorShrink.Smalltalk condenseSources.Smalltalk obsoleteClasses size. !----QUIT----#(8 October 2008 1:27:16 pm) minimal-MVC.image priorSource: 256!----STARTUP----#(8 October 2008 1:28:07 pm) as /Users/samadams/rvm-work/majorShrink work/minimal-MVC.image!----SNAPSHOT----#(8 October 2008 1:28:38 pm) minimal-MVC.image priorSource: 3856!----STARTUP----#(22 November 2010 5:34:57 pm) as /Users/smarr/Projects/PhD/IBM/images/rvm-base/rvm-base.image!'****************************************************************************** *  Copyright (c) 2008 - 2010 IBM Corporation and others. *  All rights reserved. This program and the accompanying materials *  are made available under the terms of the Eclipse Public License v1.0 *  which accompanies this distribution, and is available at *  http://www.eclipse.org/legal/epl-v10.html *  *  Contributors: *    David Ungar, IBM Research - Initial Implementation *    Sam Adams, IBM Research - Initial Implementation *    Stefan Marr, Vrije Universiteit Brussel - Port to x86 Multi-Core Systems ******************************************************************************'!DisplayText subclass: #Paragraph	instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine destFormSema'	classVariableNames: ''	poolDictionaries: 'TextConstants'	category: 'ST80-Support'!Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler name hostCore coreMask'	classVariableNames: 'SemaForSuspensions'	poolDictionaries: ''	category: 'Kernel-Processes'!Object subclass: #RVMPrimitives	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RVM-Support'!Object subclass: #ProcessorScheduler	instanceVariableNames: 'quiescentProcessLists activeProcess'	classVariableNames: 'BackgroundProcess EmergencyProcess HighIOPriority LowIOPriority SystemBackgroundPriority SystemRockBottomPriority TimingPriority UserBackgroundPriority UserInterruptPriority UserSchedulingPriority'	poolDictionaries: ''	category: 'Kernel-Processes'!FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1 interlock'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'System-Files'!View subclass: #StandardSystemView	instanceVariableNames: 'labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize collapsedViewport expandedViewport labelBits windowBits bitsValid updatablePanes displayInterlock'	classVariableNames: 'CacheBits LabelStyle'	poolDictionaries: ''	category: 'ST80-Support'!Object subclass: #Mutex	instanceVariableNames: 'semaphore owner'	classVariableNames: ''	poolDictionaries: ''	category: 'RVM-Support'!!ProcessorScheduler methodsFor: 'accessing' stamp: 'dmu 11/25/2008 00:23' prior: 19580503!activePriority	"Answer the priority level of the currently running Process."	^self thisProcess priority! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'dmu 9/16/2010 14:53'!preemptedProcess	"Return the process that the currently active process just preempted."	| list listWithoutMe |	self thisProcess priority to: 1 by: -1 do:[:priority|		list := quiescentProcessLists at: priority.		"RVM keeps running processes on the lists -- dmu 9/16/10"		listWithoutMe := list reject: [:p | p == Processor thisProcess].		listWithoutMe isEmpty ifFalse:[^listWithoutMe last].	].	^nil	"Processor preemptedProcess"! !!ProcessorScheduler methodsFor: 'process state change' stamp: 'dmu 11/25/2008 00:23' prior: 19581419!terminateActive	"Terminate the process that is currently running."	self thisProcess terminate! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:39'!areRunningProcessesInSchedulerLists	"Our RVM follows Pallas' MS system and keeps runnable processes in the scheduler lists even when running."	^RVMPrimitives isRVM! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 11/25/2008 00:26'!isActive: aProcess^ aProcess suspendedContext ==  nil! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:32'!thisProcess	^ RVMPrimitives thisProcess! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 3/22/2010 13:03'!yieldIfFewerCoresThan: n	RVMPrimitives coreCount < n    ifTrue: [self yield]! !!Project class methodsFor: 'utilities' stamp: 'dmu 11/25/2008 00:24' prior: 19633190!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor thisProcess suspend]! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/8/2010 23:41'!breakpoint	<primitive: 'primitiveBreakpoint' module: 'RVMPrimitives'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:02'!printExecutionTrace	<primitive: 'primitivePrintExecutionTrace' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:01'!printOnConsole: aString	"Prints a string onto the console"	<primitive: 'primitivePrint' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:00'!printStack	"Prints Smalltalk stack to console"	<primitive: 'primitivePrintStack' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'debugging VM' stamp: 'dmu 6/9/2010 00:01'!printVMStatistics	<primitive: 'primitivePrintStats' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'VM statistics' stamp: 'dmu 6/8/2010 23:04'!sampleRVM	"Grab some data from the VM and return it"	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>	"RVMPrimitives sampleRVM"	^ nil! !!RVMPrimitives class methodsFor: 'VM statistics' stamp: 'sm 10/27/2010 22:09'!getMainRank	"Get a sample from the VM and read out the main rank"	| sample |	sample := self sampleRVM.	^ ((sample at: 6) at: 2) at: 6! !!RVMPrimitives class methodsFor: 'VM statistics' stamp: 'dmu 6/8/2010 23:40'!sampleSpecificData: flags	"Grab some data from the VM and return it"	"Bit offsets for flags; bit 0 is 1, bit 1 is 2, bit 2 is 4, etc.		allCores, // 0	runMask,	messageNames,	cpuCoreStats,	allCoreStats,	fence,	millisecs, // 6	cycles,	messageStats,	memorySystemStats,    	interpreterStats,    	objectTableStats,    	interactionStats,   	 coreCoords, // 14    	sendTallies,    	receiveTallies,    	bufferedMessageStats,    	receiveCycles,    	// memory system    	gcStats, // 19    	heapStats,    	// interpreter    	bytecodes, // 20    	yieldCount,    	cycleCounts,    	interruptChecks,    	movedMutatedObjectStats,    	mutexStats,   	 interpreterLoopStats // 26"	<primitive: 'primitiveSampleRVM' module: 'RVMPlugin'>	^ nil! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:58'!moveAllToReadMostlyHeaps	"Move all objects into read-mostly heaps"	<primitive: 'primitiveMoveAllToReadMostlyHeaps' module: 'RVMPlugin'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:55'!shuffleToHeapsFrom: firstHeap to: lastHeap	"Deal out all objects in the system into heaps from firstHeap through lastHeap in round-robin fashion so that adjacent objects wind up in different heaps"	<primitive: 'primitiveShuffle' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:56'!shuffleToHeapsFrom: firstHeap to: lastHeap movingReadWriteObjectsToReadMostlyHeap: rwToRM  movingReadMostlyObjectsToReadWriteHeap: rmToRw	"Deal out all objects in the system into heaps from firstHeap through lastHeap in round-robin fashion so that adjacent objects wind up in different heaps"	"If rwToRM, move objects in read/write heaps to read-mostly heaps."	"If rmToRW, move objects in read-mostly heaps to read/write heaps."	<primitive: 'primitiveShuffle' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:57'!spreadToHeapsFrom: firstHeap to: lastHeap	"Spread out all objects in the system into heaps from firstHeap through lastHeap so that each heap ends up about equally full."	<primitive: 'primitiveSpread' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'rearranging objects' stamp: 'dmu 6/8/2010 23:57'!spreadToHeapsFrom: firstHeap to: lastHeap movingReadWriteObjectsToReadMostlyHeap: rwToRM  movingReadMostlyObjectsToReadWriteHeap: rmToRw	"Spread out all objects in the system into heaps from firstHeap through lastHeap so that each heap ends up about equally full."	"If rwToRM, move objects in read/write heaps to read-mostly heaps."	"If rmToRW, move objects in read-mostly heaps to read/write heaps."	<primitive: 'primitiveSpread' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:30'!for: anObject setRankTo: rank	<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:31'!for: anObject setRankTo: rank isReadWrite: isRW	<primitive: 'primitiveSetCoordinatesFor' module: 'RVMPlugin'>	self primitiveFailed! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:17'!getCoreOf: anObject	"RVMPrimitives getCoreOf: 2@3"	<primitive: 'primitiveGetCore' module: 'RVMPlugin'>	^ -1! !!RVMPrimitives class methodsFor: 'situating an object' stamp: 'dmu 6/8/2010 23:47'!getMutabilityOf: anObject	"Return true if argument is in a read/write heap, false if in read-mostly heap"	<primitive: 'primitiveGetMutability' module: 'RVMPlugin'>	^ true! !!RVMPrimitives class methodsFor: 'enumerating a heap' stamp: 'dmu 6/8/2010 23:10'!allObjectsInHeap: rank isReadWrite: trueForReadWriteFalseForReadMostly	"return array of all objects in either read/write or read-mostly heap specified by rank and trueForReadWriteFalseForReadMostly"	"RVMPrimitives allObjectsInHeap: 0 isReadWrite: true"	<primitive: 'primitiveAllObjectsInHeap' module: 'RVMPlugin'>	^ nil! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/8/2010 23:18'!getCoreIAmRunningOn	"RVMPrimitives getCoreIAmRunningOn"	<primitive: 'primitiveGetCoreIAmRunningOn' module: 'RVMPlugin' >  	^ -1! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/8/2010 23:44'!getRunMask	"Return an integer with ones corresponding to cores RVM is allowed to use: 1 means core 0, 3 means cores 0 and 1, etc."	"RVMPrimitives getRunMask printStringBase: 16"	<primitive: 'primitiveRunMask' module: 'RVMPlugin'>	^ -1! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/9/2010 00:07'!getRunningProcessesByCore	"Returns array of running processes, indexed by core (+1)"	<primitive: 'primitiveRunningProcessByCore' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/8/2010 23:46'!setRunMask: anInteger	"Sets run mask to argument and returns old run mask.	Only cores set in run mask will be used to run Smalltalk processes."	"RVMPrimitives setRunMask: 1"	<primitive: 'primitiveRunMask' module: 'RVMPlugin'>	^ -1! !!RVMPrimitives class methodsFor: 'processes' stamp: 'dmu 6/9/2010 00:04'!thisProcess	"Return the process that is running; RVM does not use ActiveProcess for this state, since many may be running"	<primitive: 'primitiveThisProcess'  module: 'RVMPlugin'>	^ Processor activeProcess! !!RVMPrimitives class methodsFor: 'cores' stamp: 'dmu 6/8/2010 23:11'!coreCount  "RVMPrimitives coreCount"  <primitive: 'primitiveCoreCount' module: 'RVMPlugin'>  ^ 1! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:25'!getCoreTrace	"RVMPrimitives getCoreTrace"	<primitive: 'primitiveTraceCores' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:26'!getMutatedReplicatedObjectsTrace	<primitive: 'primitiveTraceMutatedReplicatedObjects' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:22'!startCoreTrace: size	"RVMPrimitives startCoreTrace: 1000"	<primitive: 'primitiveTraceCores' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'tracing' stamp: 'dmu 6/8/2010 23:27'!startMutatedReplicatedObjectsTrace: size	<primitive: 'primitiveTraceMutatedReplicatedObjects' module: 'RVMPlugin'>	^ self primitiveFailed! !!RVMPrimitives class methodsFor: 'emergency evaluating' stamp: 'dmu 6/8/2010 23:19'!getEmergencySemaphore	"When you hit shift-control-a, the VM will signal the emergency semaphore, if it has been set to a semaphore"	"RVMPrimitives getEmergencySemaphore"	<primitive: 'primitiveEmergencySemaphore' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'emergency evaluating' stamp: 'dmu 6/9/2010 00:06'!setEmergencySemaphore: aSema	"When you hit shift-control-a, the VM will signal the emergency semaphore, if it has been set to a semaphore"	"RVMPrimitives setEmergencySemaphore: Semaphore new"	<primitive: 'primitiveEmergencySemaphore' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'using extra word' stamp: 'dmu 6/14/2010 15:27'!getExtraPreheaderWordOf: anObject	"Returns the extra preheader word of the argument."	"RVMPrimitives getExtraPreheaderWordOf: 3@4"	<primitive: 'primitiveGetExtraPreheaderWord' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'using extra word' stamp: 'dmu 6/14/2010 15:27'!setExtraPreheaderWordOf: anObject to: newContents	"Sets the extra preheader word of the first argument."	"|n| n := 3@4.	RVMPrimitives setExtraPreheaderWordOf: n to: 17.	RVMPrimitives getExtraPreheaderWordOf: n"	<primitive: 'primitiveSetExtraPreheaderWord' module: 'RVMPlugin'>! !!RVMPrimitives class methodsFor: 'using extra word' stamp: 'dmu 6/9/2010 00:05'!setExtraWordSelector: aSelector	"returns the old one"	<primitive: 'primitiveSetExtraWordSelector' module: 'RVMPlugin'>	^self primitiveFailed! !!RVMPrimitives class methodsFor: 'testing' stamp: 'dmu 6/14/2010 15:36'!isRVM	"RVMPrimitives isRVM"	^ (self getCoreOf: nil) ~= -1! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 6/14/2010 16:14'!valueAt: blockPriority 	"Evaluate the receiver (block), with another priority as the actual one 	and restore it afterwards. The caller should be careful with using 	higher priorities."	| activeProcess result outsidePriority |	activeProcess := Processor thisProcess.	outsidePriority := activeProcess priority.	activeProcess priority: blockPriority.	result := self				ensure: [activeProcess priority: outsidePriority].	"Yield after restoring lower priority to give the preempted processes a  	chance to run."	blockPriority > outsidePriority		ifTrue: [Processor yield].	^ result! !!BlockContext methodsFor: 'private' stamp: 'dmu 11/25/2008 00:18' prior: 16957083!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess := Processor thisProcess.	oldPriority := activeProcess priority.	activeProcess priority: Processor highestPriority.	result := self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!CPUWatcher methodsFor: 'process operations' stamp: 'dmu 11/25/2008 00:18' prior: 17097534!debugProcess: aProcess	| uiPriority oldPriority |	uiPriority := Processor thisProcess priority.	aProcess priority >= uiPriority ifTrue: [		oldPriority := ProcessBrowser setProcess: aProcess toPriority: uiPriority - 1	].	ProcessBrowser debugProcess: aProcess.! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:19' prior: 17828079!inActiveControllerProcess	"Answer whether the active scheduling process is the actual active 	process in the system."	^activeControllerProcess == Processor thisProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:19' prior: 17829454!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController := nil.	activeControllerProcess := Processor thisProcess.! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:20' prior: 17830158!scheduleActiveNoTerminate: aController 	"Make aController be the active controller. Presumably the process that 	requested the new active controller wants to keep control to do more 	activites before the new controller can take control. Therefore, do not 	terminate the currently active process."	self schedulePassive: aController.	self scheduled: aController		from: Processor thisProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'dmu 11/25/2008 00:20' prior: 17831145!searchForActiveController	"Find a scheduled controller that wants control and give control to it. If 	none wants control, then see if the System Menu has been requested."	| aController |	activeController := nil.	activeControllerProcess := Processor thisProcess.	self activeController: self nextActiveController.	Processor terminateActive! !!Cursor methodsFor: 'displaying' stamp: 'dmu 6/14/2010 16:15' prior: 17854130!showWhile: aBlock 	"While evaluating the argument, aBlock, make the receiver be the cursor shape."	"ar 2/2/2006: Only allow this if active process is ui process"	| oldcursor |	Processor thisProcess == Project uiProcess ifFalse:[^aBlock value].	oldcursor := Sensor currentCursor.	self show.	^aBlock ensure: [oldcursor show]! !!Paragraph methodsFor: 'RVM' stamp: 'dmu 6/15/2010 11:36'!destFormSema: s	destFormSema := s! !!Paragraph methodsFor: 'private' stamp: 'ssa 4/7/2009 12:39' prior: 19144313!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	destFormSema isNil ifTrue:[self destFormSema: Semaphore forMutualExclusion].	destFormSema critical: [		saveDestinationForm _ destinationForm.		self destinationForm: aDisplayMedium.		self displayLines: lineInterval.		destinationForm _ saveDestinationForm	]! !!Process methodsFor: 'accessing' stamp: 'ssa 2/17/2009 22:34' prior: 19542869!isActiveProcess	^ Processor areRunningProcessesInSchedulerLists		ifTrue: [ suspendedContext isNil and:[myList notNil]]		ifFalse: [self == Processor activeProcess]! !!Process methodsFor: 'changing process state' stamp: 'dmu 6/14/2010 16:16'!run	"Suspend current process and execute self instead"	| proc |	proc := Processor thisProcess.	[	proc suspend.		self resume.	] forkAt: Processor highestPriority! !!Process methodsFor: 'changing process state' stamp: 'dmu 3/24/2010 15:44' prior: 19536714!suspend	"Stop the process that the receiver represents in such a way 	that it can be restarted at a later time (by sending the receiver the 	message resume). If the receiver represents the activeProcess, suspend it. 	Otherwise remove the receiver from the list of waiting processes."	self isActiveProcess ifTrue: [		self nilMyListUnlessRVM.		self primitiveSuspend.	] ifFalse: [		myList ifNotNil: [			myList remove: self ifAbsent: [].			myList := nil].	]! !!Process methodsFor: 'changing process state' stamp: 'dmu 3/24/2010 15:45' prior: 19537249!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock |	self == Processor thisProcess  ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self nilMyListUnlessRVM.		self primitiveSuspend.	] ifFalse: [	        self suspend.		myList ifNotNil: [			myList remove: self ifAbsent: [].			myList := nil].		suspendedContext ifNotNil: [			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:05' prior: 19538157!activateReturn: aContext value: value	"Activate 'aContext return: value', so execution will return to aContext's sender"	self suspend.	^ suspendedContext := suspendedContext activateReturn: aContext value: value! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:01' prior: 19538438!complete: aContext 	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."		| ctxt pair error |	self suspend.	ctxt := suspendedContext.	suspendedContext := nil.  "disable this process while running its stack in active process below"	pair := ctxt runUntilErrorOrReturnFrom: aContext.	suspendedContext := pair first.	error := pair second.	error ifNotNil: [^ error signalerContext].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 6/14/2010 16:06'!install: aContext 	"Replace the suspendedContext with aContext."	(Processor isActive: self)		ifTrue: [^self error: 'An active process cannot install contexts'].	suspendedContext := aContext! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 6/14/2010 16:07' prior: 19539515!popTo: aContext 	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."	| callee |	(Processor isActive: self)		ifTrue: [^ self error: 'An active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ aContext].  "aContext is on top"	^ self return: callee value: callee receiver! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 6/14/2010 16:08'!popTo: aContext value: aValue	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	| callee |	(Processor isActive: self)		ifTrue: [^ self error: 'An active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ self].  "aContext is on top"	self return: callee value: aValue! !!Process class methodsFor: 'accessing' stamp: 'ssa 3/25/2010 15:11'!semaForSuspensions	SemaForSuspensions isNil ifTrue:[SemaForSuspensions := Semaphore forMutualExclusion].	^SemaForSuspensions! !!Process methodsFor: 'debugging' stamp: 'dmu 9/17/2010 12:03' prior: 19545989!debug: context title: title full: bool	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt :=  self == Processor thisProcess  ifTrue: [thisContext] 		ifFalse: [			self suspend.  			self suspendedContextWaitingIfNecessary].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].		Transcript cr; show: 'launching debugger'.	Debugger openOn: self context: context label: title contents: nil fullView: bool.! !!Process methodsFor: 'debugging' stamp: 'dmu 9/17/2010 12:03' prior: 19546414!debugWithTitle: title	"Open debugger on self"	| context |	context := self == Processor thisProcess  ifTrue: [thisContext] ifFalse: [ self suspend.  self suspendedContextWaitingIfNecessary].	self debug: context title: title full: true.! !!Process methodsFor: 'signaling' stamp: 'ssa 2/17/2009 22:31' prior: 19546678!pvtSignal: anException list: aList	"Private. This method is used to signal an exception from another	process...the receiver must be the active process.  If the receiver 	was previously waiting on a Semaphore, then return the process	to the waiting state after signaling the exception and if the Semaphore	has not been signaled in the interim"	"Since this method is not called in a normal way, we need to take care	that it doesn't directly return to the caller (because I believe that could	have the potential to push an unwanted object on the caller's stack)."	| blocker |	self == Processor thisProcess ifFalse: [^self].	self suspend.	anException signal.	blocker := Semaphore new.	[self suspend.	suspendedContext := suspendedContext swapSender: nil.	aList class == Semaphore 		ifTrue:			[aList isSignaled				ifTrue: 					[aList wait.  "Consume the signal that would have restarted the receiver"					self resume]				ifFalse:					["Add us back to the Semaphore's list (and remain blocked)"					myList := aList.					aList add: self]]		ifFalse: [self resume]] fork.	blocker wait.! !!Process methodsFor: 'signaling' stamp: 'dmu 6/14/2010 16:11'!signalException: anException	"Signal an exception in the receiver process...if the receiver is currently	suspended, the exception will get signaled when the receiver is resumed.  If 	the receiver is blocked on a Semaphore, it will be immediately re-awakened	and the exception will be signaled; if the exception is resumed, then the receiver	will return to a blocked state unless the blocking Semaphore has excess signals"	| oldList |	"If we are the active process, go ahead and signal the exception"	self == Processor thisProcess  ifTrue: [^anException signal].	"Suspend myself first to ensure that I won't run away in the	midst of the following modifications."	myList ifNotNil:[oldList := self suspend].	"Add a new method context to the stack that will signal the exception"	suspendedContext := MethodContext		sender: suspendedContext		receiver: self		method: (self class lookupSelector: #pvtSignal:list:)		arguments: (Array with: anException with: oldList).	"If we are on a list to run, then suspend and restart the receiver 	(this lets the receiver run if it is currently blocked on a semaphore).  If	we are not on a list to be run (i.e. this process is suspended), then when the	process is resumed, it will signal the exception"	oldList ifNotNil: [self resume].! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:40'!coreMask	^ coreMask! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:40'!coreMask: m	coreMask := m! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:41'!hostCore	^ hostCore! !!Process methodsFor: 'RVM' stamp: 'dmu 6/14/2010 15:31'!isRunning	Processor thisProcess == self ifTrue: [^ true].	self isActiveProcess ifTrue: [^ true].	myList ifNil: [^ false].	^ myList class ~~ Semaphore! !!Process methodsFor: 'RVM' stamp: 'ssa 3/2/2010 18:23'!nilMyListUnlessRVM	Processor areRunningProcessesInSchedulerLists ifFalse: [		"primitiveSuspend will use myList to remove from list and will nil it out"		myList := nil.	]! !!ProcessBrowser methodsFor: 'stack list' stamp: 'dmu 6/14/2010 16:17' prior: 19567972!updateStackList: depth 	| suspendedContext oldHighlight |	selectedProcess		ifNil: [^ self changeStackListTo: nil].	(stackList notNil and: [ stackListIndex > 0 ])		ifTrue: [oldHighlight := stackList at: stackListIndex].	selectedProcess == Processor thisProcess		ifTrue: [self				changeStackListTo: (thisContext stackOfSize: depth)]		ifFalse: [suspendedContext := selectedProcess suspendedContext.			suspendedContext				ifNil: [self changeStackListTo: nil]				ifNotNil: [self						changeStackListTo: (suspendedContext stackOfSize: depth)]].	self		stackListIndex: (stackList				ifNil: [0]				ifNotNil: [stackList indexOf: oldHighlight])! !!ProcessBrowser class methodsFor: 'process control' stamp: 'ssa 6/11/2010 14:35' prior: 19573660!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	^ [aProcess caseOf: {		[ProcessorScheduler emergencyProcess] -> [{'emergency evaluator ShftCtrl-A'. false. true}].		[] -> [{'no process'. false. false}].		[Smalltalk lowSpaceWatcherProcess] -> [{'the low space watcher'. false. false}].		[WeakArray runningFinalizationProcess] -> [{'the WeakArray finalization process'. false. false}].		[Processor thisProcess] -> [{'the UI process'. false. true}].		[Processor backgroundProcess] -> [{'the idle process'. false. false}].		[Sensor interruptWatcherProcess] -> [{'the user interrupt watcher'. false. false}].		[Sensor eventTicklerProcess] -> [{'the event tickler'. false. false}].		[Project uiProcess] -> [{'the inactive Morphic UI process'. false. false}].		[Smalltalk			at: #SoundPlayer			ifPresent: [:sp | sp playerProcess]] -> [{'the Sound Player'. false. false}].		[ScheduledControllers			ifNotNil: [ScheduledControllers activeControllerProcess]] -> [{'the inactive MVC controller process'. false. true}].		[Smalltalk			at: #CPUWatcher			ifPresent: [:cw | cw currentWatcherProcess]] -> [{'the CPUWatcher'. false. false}]}		 otherwise: 			[(aProcess priority = Processor timingPriority					and: [aProcess suspendedContext receiver == Delay])				ifTrue: [{'the timer interrupt watcher'. false. false}]				ifFalse: [{aProcess suspendedContext asString. true. true}]]]		ifError: [:err :rcvr | {aProcess suspendedContext asString. true. true}]! !!BitBlt methodsFor: 'accessing' stamp: 'dmu 4/4/2009 00:24'!copyBitsOnMain	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap _ colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'dmu 4/4/2009 00:20'!copyBitsLocally	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBitsLocally'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap _ colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/3/2009 23:01'!drawLoopLocallyX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| |	<primitive: 'primitiveDrawLoopLocally'>self primitiveFailed! !!BitBlt methodsFor: 'line drawing' stamp: 'ssa 4/3/2009 22:36'!globalDrawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy.						P _ P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx.						P _ P + px].				i < px ifTrue: [self copyBits]]]! !!BitBlt methodsFor: 'line drawing' stamp: 'ssa 4/3/2009 22:52'!localDrawLoopX: xDelta Y: yDelta 	"Primitive"	<primitive: 'primitiveDrawLoopLocally'>	^self primitiveFailed! !!ControlManager methodsFor: 'accessing' stamp: 'ssa 3/25/2010 16:14' prior: 17823066!activeControllerNoTerminate: aController andProcess: aProcess	"Set aController to be the currently active controller and aProcess to be 	the process that handles controller scheduling activities in the 	system. This message differs from activeController:andProcess: in that it 	does not send controlTerminate to the currently active controller."	self inActiveControllerProcess		ifTrue: 			[aController~~nil				ifTrue: [(scheduledControllers includes: aController)							ifTrue: [self promote: aController]							ifFalse: [self error: 'Old controller not scheduled']].			activeController _ aController.			activeController == nil				ifFalse: [activeController controlInitialize].			activeControllerProcess _ aProcess.			activeControllerProcess resume]		ifFalse: 			['New active controller process must be set from old one, resetting...' print.			self reset.			] ! !!ControlManager methodsFor: 'scheduling' stamp: 'ssa 3/2/2010 14:12' prior: 17828328!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor thisProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString 			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ssa 3/25/2010 16:17'!reset	"ssa - reset the window controller process"	| newProcess |	newProcess := [ScheduledControllers resetActiveController.			ScheduledControllers searchForActiveController] fixTemps newProcess priority: Processor userSchedulingPriority.	newProcess resume.	"lose the current process"	"Processor terminateActive"! !!Controller methodsFor: 'basic control sequence' stamp: 'dmu 3/22/2010 14:25' prior: 17840357!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	[RVMPrimitives isRVM ifTrue: [Processor yield. ^ self].].	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait <= MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							"(Delay forMilliseconds: wait) wait "]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!EventSensor methodsFor: 'accessing' stamp: 'ssa 12/17/2009 12:30'!nextEvent	"Return the next event from the receiver."	eventQueue == nil 		ifTrue:[^self nextEventSynthesized]		ifFalse:[^self nextEventFromQueue]! !!EventSensor methodsFor: 'initialize' stamp: 'nk 6/21/2004 10:42' prior: 18149227!startUp	"Run the I/O process"	self initialize.	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).	super startUp.	self installEventTickler.	Smalltalk isMorphic ifTrue:[self flushAllButDandDEvents].	"Attempt to discover whether the input semaphore is actually being signaled."	hasInputSemaphore := false.	inputSemaphore initSignals.! !!EventSensor methodsFor: 'private' stamp: 'ssa 12/17/2009 14:18' prior: 18150960!flushNonKbdEvents	eventQueue ifNil: [^ self].	[^self]value.   "don't flush so we don't lose events"	eventQueue flushAllSuchThat:		[:buf | (self isKbdEvent: buf) not]! !!EventSensor methodsFor: 'private' stamp: 'ar 2/6/2004 14:42'!nextEventFromQueue	"Return the next event from the receiver."	eventQueue isEmpty ifTrue:[self fetchMoreEvents].	eventQueue isEmpty		ifTrue:[^nil]		ifFalse:[^eventQueue next]! !!EventSensor methodsFor: 'private' stamp: 'nk 3/17/2004 07:09'!nextEventSynthesized	"Return a synthesized event. This method is called if an event driven client wants to receive events but the primary user interface is not event-driven (e.g., the receiver does not have an event queue but only updates its state). This can, for instance, happen if a Morphic World is run in an MVC window. To simplify the clients work this method will always return all available keyboard events first, and then (repeatedly) the mouse events. Since mouse events come last, the client can assume that after one mouse event has been received there are no more to come. Note that it is impossible for EventSensor to determine if a mouse event has been issued before so the client must be aware of the possible problem of getting repeatedly the same mouse events. See HandMorph>>processEvents for an example on how to deal with this."	| kbd array buttons pos modifiers mapped |	"First check for keyboard"	array _ Array new: 8.	kbd _ self primKbdNext.	kbd ifNotNil:		["simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^ array].	"Then check for mouse"	pos _ self primMousePt.	buttons _ mouseButtons.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.	^ array! !!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26' prior: 18153333!primMouseButtons	self fetchMoreEvents.	self flushNonKbdEvents.	^ mouseButtons! !!EventSensor methodsFor: 'private' stamp: 'ssa 12/16/2009 13:26' prior: 18153481!primMousePt	self fetchMoreEvents.	self flushNonKbdEvents.	^ mousePosition! !!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/17/2009 12:46' prior: 18156673!processEvent: evt 	"Process a single event. This method is run at high priority."	| type |	type := evt at: 1.	"Tackle mouse events first"	type = EventTypeMouse		ifTrue: [evt				at: 5				put: (ButtonDecodeTable at: (evt at: 5)							+ 1). 				self queueEvent: evt.				self processMouseEvent: evt . 				^self].		"Store the event in the queue if there's any"	type = EventTypeKeyboard		ifTrue: [ "Check if the event is a user interrupt"			((evt at: 4) = 0				and: [((evt at: 3)						bitOr: (((evt at: 5)							bitAnd: 8)							bitShift: 8))							= interruptKey])					ifTrue: ["interrupt key is meta - not reported as event"							^ interruptSemaphore signal].			"Else swap ctrl/alt keys if neeeded.wi"			KeyDecodeTable				at: {evt at: 3. evt at: 5}				ifPresent: [:a | evt at: 3 put: a first;						 at: 5 put: a second]. 			self queueEvent: evt. 			self processKeyboardEvent: evt . 			^self ].					"Handle all events other than Keyborad or Mouse."	self queueEvent: evt.	! !!EventSensor methodsFor: 'private-I/O' stamp: 'ssa 12/16/2009 13:12' prior: 18157615!processKeyboardEvent: evt	"process a keyboard event, updating InputSensor state"	| charCode pressCode |	"Never update keyboardBuffer if we have an eventQueue active"	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).	eventQueue ifNotNil:[^self]. 	charCode _ evt at: 3.	charCode = nil ifTrue:[^self]. "extra characters not handled in MVC"	pressCode _ evt at: 4.	pressCode = EventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"	"mix in modifiers"	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).	keyboardBuffer nextPut: charCode .! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:38'!forkOn: aCore	"Create and schedule a Process running the code in the receiver."	^ self newProcess resumeOn: aCore! !!BlockContext methodsFor: 'scheduling' stamp: 'ssa 4/8/2009 20:09'!forkOn: aCore with: anObject	"Create and schedule a Process running the code in the receiver."	^ (self newProcessWith: anObject) resumeOn: aCore! !!BlockContext methodsFor: 'scheduling' stamp: 'ssa 4/8/2009 20:08'!forkOn: aCore with: anObject at: aPriority	"Create and schedule a Process running the code in the receiver."	| proc |	proc _ self newProcessWith: anObject.	proc priority: aPriority.	^proc resumeOn: aCore! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:34'!forkWith: anObject	"Create and schedule a Process running the code in the receiver."	^ (self newProcessWith: anObject) resume! !!BlockContext methodsFor: 'scheduling' stamp: 'dmu 4/7/2009 02:33'!newProcessWith: anObject	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value: anObject.			Processor terminateActive]		priority: Processor activePriority! !!Delay class methodsFor: 'snapshotting' stamp: 'dmu 5/25/2010 11:02' prior: 18001174!startUp	"Restart active delay, if any, when resuming a snapshot."	self restoreResumptionTimes.	ActiveDelay == nil ifFalse: [ActiveDelay activate].	AccessProtect _ Semaphore forMutualExclusion! !!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!hostCore: anObject	"Set the value of hostCore"	hostCore _ anObject! !!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!myList	"Answer the value of myList"	myList isNil ifTrue:[self myList: nil].	^ myList! !!Process methodsFor: 'accessing' stamp: 'dmu 3/8/2010 20:26'!myList: anObject	"Set the value of myList"	myList _ anObject! !!Process methodsFor: 'changing process state' stamp: 'dmu 3/2/2010 17:02' prior: 19535920!primitiveSuspend	"Primitive. Stop the process that self represents in such a way 	that it can be restarted at a later time (by sending #resume).	ASSUMES self is the active process.	Essential. See Object documentation whatIsAPrimitive."	"Debugging code below causes terminated running processes to seem not terminated. -- dmu 3/2/10"	"(myList isNil and: [RVMPrimitives isRVM]) ifTrue:[self halt]."	<primitive: 88>	self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'dmu 3/24/2010 15:44' prior: 19536280!resume	"Allow the process that the receiver represents to continue. Put  	the receiver in line to become the activeProcess. Check for a nil 	suspendedContext, which indicates a previously terminated Process that 	would cause a vm crash if the resume attempt were permitted"	suspendedContext ifNil: [^ self primitiveFailed].	^ self primitiveResume! !!Process methodsFor: 'changing process state' stamp: 'dmu 4/7/2009 02:41'!resumeOn: aCore  self useOnlyCore: aCore.  self resume! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:04' prior: 19540822!return: aContext value: value	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."        self suspend.	suspendedContext == aContext ifTrue: [		^ suspendedContext _ aContext return: value from: aContext].	self activateReturn: aContext value: value.	^ self complete: aContext.! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:03' prior: 19541263!step         self suspend.	^ suspendedContext _ suspendedContext step! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:04' prior: 19541683!stepToCallee	"Step until top context changes"	| ctxt |	self suspend.	ctxt _ suspendedContext.	[ctxt == suspendedContext] whileTrue: [		suspendedContext _ suspendedContext step].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'dmu 12/2/2008 14:05' prior: 19542330!stepToSendOrReturnself suspend.	^ suspendedContext _ suspendedContext stepToSendOrReturn! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 02:57'!avoidCore: anIndex	"Force this process to avoid this core (0-55)"	self coreMask: (self coreMask bitClear: (1 bitShift: anIndex))! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 03:49'!avoidCores: aCollectionOfIndicies	"Force this process to avoid these cores (0-55)"	| mask |	mask _ 0.	aCollectionOfIndicies do:[:index| mask _ mask bitOr: (1 bitShift: index)].	self coreMask: (self coreMask bitClear:mask)! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 02:59'!useAdditionalCore: anIndex	"Force this process to only urn on this core (0-55)"	self coreMask: (self coreMask bitOr:(1 bitShift: anIndex))! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 03:50'!useAdditionalCores: aCollectionOfIndicies	"Allow this process to run on these additional cores (0-55)"	| mask |	mask _ 0.	aCollectionOfIndicies do:[:index| mask _ mask bitOr: (1 bitShift: index)].	self coreMask: (self coreMask bitOr:mask)! !!Process methodsFor: 'core assignment' stamp: 'dmu 5/5/2009 01:32'!useOnlyCore: anIndex	"Force this process to only run on this core (0-55)"	self coreMask: (1 bitShift: anIndex)! !!Process methodsFor: 'core assignment' stamp: 'ssa 2/26/2009 03:02'!useOnlyCores: aCollectionOfIndicies	"Force this process to only run on these cores (0-55)"	| mask |	mask _ 0.	aCollectionOfIndicies do:[:index| mask _ mask bitOr: (1 bitShift: index)].	self coreMask: mask! !!Process methodsFor: 'core assignment' stamp: 'dmu 1/25/2010 11:06'!useOnlyMainCore	RVMPrimitives isRVM ifTrue: [self useOnlyCore: (RVMPrimitives getMainRank)]! !!Process methodsFor: 'signaling' stamp: 'ssa 2/17/2009 22:30' prior: 19547829!signal: anException	"Signal an exception in the receiver process...if the receiver is currently	suspended, the exception will get signaled when the receiver is resumed.  If 	the receiver is blocked on a Semaphore, it will be immediately re-awakened	and the exception will be signaled; if the exception is resumed, then the receiver	will return to a blocked state unless the blocking Semaphore has excess signals"	"If we are the active process, go ahead and signal the exception"	self == Processor thisProcess ifTrue: [^anException signal].        self suspend.	"Add a new method context to the stack that will signal the exception"	suspendedContext := MethodContext		sender: suspendedContext		receiver: self		method: (self class methodDict at: #pvtSignal:list:)		arguments: (Array with: anException with: myList).	"If we are on a list to run, then suspend and restart the receiver 	(this lets the receiver run if it is currently blocked on a semaphore).  If	we are not on a list to be run (i.e. this process is suspended), then when the	process is resumed, it will signal the exception"	myList ifNotNil: [self suspend; resume].! !!Process class methodsFor: 'instance creation' stamp: 'dmu 3/24/2010 15:46' prior: 19549103!forContext: aContext priority: anInteger 	"Answer an instance of me that has suspended aContext at priority 	anInteger."	| newProcess |	newProcess _ self new.	newProcess suspendedContext: aContext.	newProcess priority: anInteger.	[newProcess coreMask:(1 bitShift: 27)].	^newProcess! !!Process class methodsFor: 'instance creation' stamp: 'ssa 2/26/2009 02:45'!forContext: aContext priority: anInteger coreMask: anIntegerMask	"Answer an instance of me that has suspended aContext at priority 	anInteger using this coreMask."	| newProcess |	newProcess _ self forContext: aContext priority: anInteger.	newProcess coreMask:anIntegerMask.	^newProcess! !!ProcessorScheduler methodsFor: 'removing' stamp: 'ssa 6/11/2010 14:37'!removeAllPossible	"Terminate and remove all processes that you can.	This should leave the standard set only"	self terminatableProcesses print do:[:proc| proc terminate]! !!ProcessorScheduler methodsFor: 'removing' stamp: 'ssa 6/11/2010 14:31'!terminatableProcesses	"Answer all current processes that may be user terminated like in the ProcessBrowser"	"self terminatableProcesses"	| processList |	Smalltalk garbageCollectMost. "lose defunct processes"	processList _ Process allSubInstances				reject: [:each | each isTerminated].	processList _ processList				sortBy: [:a :b | a priority >= b priority].	processList _ WeakArray withAll: processList.	^processList select:[:proc| (ProcessBrowser nameAndRulesFor: proc) at: 2]! !!Project methodsFor: 'menu messages' stamp: 'dmu 11/25/2008 00:23' prior: 19605808!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject _ self.	Display newDepthNoRestore: displayDepth.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	world isMorph		ifTrue:			["Entering a Morphic project"			World _ world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World _ nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess _ Processor thisProcess.! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:07'!interlock	interlock ifNil: [self interlock: Semaphore forMutualExclusion].	^ interlock! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:07'!interlock: aSemaphore	interlock _ aSemaphore! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:14'!resetInterlock	self interlock signal.	self interlock: nil! !!StandardFileStream methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:09'!safelyDo: aBlock	^ self interlock critical: aBlock! !!StandardFileStream class methodsFor: 'RVM' stamp: 'dmu 9/7/2010 14:14'!resetAllInterlocks	"self resetAllInterlocks"	self allSubInstancesDo: [:sfs| sfs resetInterlock]! !!RemoteString methodsFor: 'accessing' stamp: 'dmu 9/7/2010 17:19' prior: 19744618!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile theText |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.		theFile safelyDo: [		theFile position: filePositionHi.		theText _ theFile nextChunkText].	^theText! !!SyntaxError class methodsFor: 'instance creation' stamp: 'dmu 11/25/2008 00:25' prior: 20222560!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"		topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor thisProcess suspend.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'dmu 9/7/2010 14:26' prior: 20274585!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	Object flushDependents.	Object flushEvents.	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString, ' ', (FileDirectory default localNameFor: self imageName).		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		self assureStartupStampLogged.		(SourceFiles at: 2) safelyDo: [			LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.			self logChange: msg , sourceLink.		].		Transcript cr; show: msg].	self processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming _ embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming _ false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming == true ifTrue: [self clearExternalObjects].	self processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self readDocumentFile].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!UnhandledError methodsFor: 'priv handling' stamp: 'dmu 11/25/2008 00:25' prior: 20491223!devDefaultAction	Processor thisProcess		debug: exception signalerContext		title: exception description! !!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:42' prior: 20039338!deEmphasizeLabel	"Un-Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self critical: [		self displayLabelBackground: false.		self displayLabelText.	]! !Cursor initialize!Controller initialize!!BitBlt methodsFor: 'copying' stamp: 'ssa 4/7/2009 13:44'!OLDcopyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap _ colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[^self copyBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'dmu 5/10/2009 08:43' prior: 16904030!copyBits	RVMPrimitives isRVM ifFalse:[^self OLDcopyBits]. 	destForm == Display  ifTrue: [self copyBitsOnMain] ifFalse: [self copyBitsLocally]! !!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/10/2009 22:47' prior: 16910364!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards _ (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 _ startPoint. point2 _ stopPoint]		ifFalse: [point1 _ stopPoint. point2 _ startPoint].	sourceForm == nil ifTrue:		[destX _ point1 x.		destY _ point1 y]		ifFalse:		[width _ sourceForm width.		height _ sourceForm height.		offset _ sourceForm offset.		destX _ (point1 x + offset x) rounded.		destY _ (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].		(destForm == Display or:[RVMPrimitives isRVM not]) ifTrue: [	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded]			ifFalse: [self drawLoopLocallyX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded].	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].! !!BitBlt methodsFor: 'line drawing' stamp: 'dmu 4/10/2009 22:47' prior: 16911722!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."			^(destForm == Display  or:[RVMPrimitives isRVM not])			ifTrue:[self globalDrawLoopX:xDelta Y: yDelta ]			ifFalse:[self localDrawLoopX:xDelta Y: yDelta ]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'dmu 9/7/2010 14:17' prior: 17482932!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue:		[SystemChangeNotifier uniqueInstance classCommented: self.		^ self organization classComment: aString stamp: aStamp].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file safelyDo: [			file setToEnd; cr; nextPut: $!!.	"directly"			"Should be saying (file command: 'H3') for HTML, but ignoring it here"			header _ String streamContents: [:strm | strm nextPutAll: self name;				nextPutAll: ' commentStamp: '.				aStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: ptr printString].			file nextChunkPut: header]]].	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.	SystemChangeNotifier uniqueInstance classCommented: self.! !!CompiledMethod methodsFor: 'source code management' stamp: 'dmu 9/7/2010 14:23' prior: 17739252!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString  st80str |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	SmalltalkImage current assureStartupStampLogged.	file safelyDo: [		file setToEnd.		preambleBlock value: file.  "Write the preamble"		(methodNode isKindOf: DialectMethodNode)			ifTrue:			["This source was parsed from an alternate syntax.			We must convert to ST80 before logging it."			st80str _ (DialectStream dialect: #ST80 contents: [:strm | methodNode printOn: strm])							asString.			remoteString _ RemoteString newString: st80str							onFileNumber: fileIndex toFile: file]			ifFalse:			[remoteString _ RemoteString newString: sourceStr							onFileNumber: fileIndex toFile: file].		file nextChunkPut: ' '.		InMidstOfFileinNotification signal ifFalse: [file flush].		self checkOKToAdd: sourceStr size at: remoteString position.		self setSourcePosition: remoteString position inFile: fileIndex	]! !!RemoteString methodsFor: 'private' stamp: 'dmu 9/7/2010 14:23' prior: 19745088!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile _ SourceFiles at: fileNumber.		theFile safelyDo: [			theFile setToEnd; cr.			self string: aString onFileNumber: fileNumber toFile: theFile]		]! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'dmu 9/7/2010 14:26' prior: 20282269!writeRecentCharacters: nCharacters toFileNamed: aFilename	"Schedule an editable text view on the last n characters of changes."	| changes |	changes _ SourceFiles at: 2.	changes safelyDo: [		changes setToEnd; skip: nCharacters negated.		(FileStream newFileNamed: aFilename) nextPutAll: (changes next: nCharacters); close; open; edit	]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'dmu 9/7/2010 14:25' prior: 19943974!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile _ SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile safelyDo: [		changesFile setToEnd; cr; cr.		changesFile nextChunkPut: aString.			"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"		self forceChangesToDisk.	]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'dmu 9/7/2010 14:25' prior: 19941473!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile isReadOnly ifTrue:[^self].	changesFile safelyDo: [		changesFile setToEnd; cr; cr.		changesFile nextChunkPut: StartupStamp asString; cr.		StartupStamp _ nil.		self forceChangesToDisk.	]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'dmu 9/7/2010 14:22' prior: 17494709!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile safelyDo: [			sourceFile position: oldPos.			preamble size > 0 ifTrue:    "Copy the preamble"				[outStream copyPreamble: preamble from: sourceFile].			"Copy the method chunk"			newPos _ outStream position.			outStream copyMethodChunkFrom: sourceFile.			sourceFile skipSeparators.      "[" "The following chunk may have ]style[" "]"			sourceFile peek == "[" $] ifTrue: [				outStream cr; copyMethodChunkFrom: sourceFile].			moveSource ifTrue:    "Set the new method source pointer"				[endPos _ outStream position.				method checkOKToAdd: endPos - newPos at: newPos.				method setSourcePosition: newPos inFile: fileIndex]]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'dmu 9/7/2010 14:12' prior: 20006999!install	"Replace SourceFiles by an instance of me with the standard sources and changes files.	This only works if SourceFiles is either an Array or an instance of this class"	"StandardSourceFileArray install"	StandardFileStream resetAllInterlocks.	SourceFiles _ self new initialize! !!ProcessorScheduler methodsFor: 'RVM' stamp: 'dmu 9/17/2010 11:02'!userBackgroundPriority	^ UserBackgroundPriority! !!Process methodsFor: 'RVM' stamp: 'dmu 9/17/2010 11:59'!suspendedContextWaitingIfNecessary	"In RVM, can suspend some other running process, and so after sending suspend, suspendedContext may still be nil."		[self suspendedContext isNil] whileTrue.	^ self suspendedContext! !!ParagraphEditor methodsFor: 'do-its' stamp: 'dmu 9/17/2010 12:00' prior: 19274468!debug: aCompiledMethod receiver: anObject in: evalContext	| selector guineaPig debugger context |	selector _ evalContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:].	anObject class addSelectorSilently: selector withMethod: aCompiledMethod.	guineaPig _ evalContext isNil		ifTrue: [[anObject DoIt] newProcess]		ifFalse: [[anObject DoItIn: evalContext] newProcess].	context _ guineaPig suspendedContextWaitingIfNecessary.	debugger _ Debugger new		process: guineaPig		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: context		isolationHead: nil.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod]		whileFalse: [debugger send].	anObject class basicRemoveSelector: selector! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:37'!displayInterlock	displayInterlock ifNil: [self displayInterlock: Mutex new].	^ displayInterlock! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:24'!displayInterlock: aSemaphore	displayInterlock _ aSemaphore! !!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:31' prior: 20040264!displayEmphasized	"Display with label highlighted to indicate that it is active."	self  critical: [		self displayDeEmphasized; emphasize.		isLabelComplemented _ true	]! !!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:30' prior: 20039727!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	self  critical: [		(bitsValid and: [controller ~~ ScheduledControllers activeController])			ifTrue: [self lock.					windowBits displayAt: self windowOrigin]			ifFalse: [Display deferUpdates: true.					super display.					Display deferUpdates: false; forceToScreen: self windowBox.					CacheBits ifTrue: [self cacheBitsAsIs]]	]! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:37'!critical: aBlock	^self displayInterlock critical: aBlock! !!Mutex commentStamp: '<historical>' prior: 0!A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.Instance variables:	semaphore	<Semaphore>		The (primitive) semaphore used for synchronization.	owner		<Process>		The process owning the mutex.!!Mutex methodsFor: 'initialize' stamp: 'das 11/3/2005 22:53'!initialize	semaphore := Semaphore forMutualExclusion.! !!Mutex methodsFor: 'mutual exclusion' stamp: 'dmu 6/14/2010 16:16'!critical: aBlock	"Evaluate aBlock protected by the receiver."	| activeProcess |	activeProcess := Processor thisProcess.	activeProcess == owner ifTrue:[^aBlock value].	^semaphore critical:[		owner := activeProcess.		aBlock ensure:[owner := nil]].! !!Mutex commentStamp: 'dmu 9/17/2010 12:34' prior: 33630747!A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.Brought in from Squeak 4.1 because we need it.Instance variables:	semaphore	<Semaphore>		The (primitive) semaphore used for synchronization.	owner		<Process>		The process owning the mutex.!!StandardSystemView methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:42' prior: 20044386!emphasizeLabel	"Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self critical: [		self displayLabelBackground: true.		self displayLabelBoxes.		self displayLabelText.	]! !!StandardSystemView methodsFor: 'RVM' stamp: 'dmu 9/17/2010 12:47'!resetDisplayInterlock	self displayInterlock: nil! !!ControlManager methodsFor: 'displaying' stamp: 'dmu 9/17/2010 12:48' prior: 17832883!restore 	"Clear the screen to gray and then redisplay all the scheduled views.  Try to be a bit intelligent about the view that wants control and not display it twice if possible."	scheduledControllers first view uncacheBits.  "assure refresh"	self unschedule: screenController; scheduleOnBottom: screenController.	screenController view window: Display boundingBox; displayDeEmphasized.	self scheduledWindowControllers reverseDo:		[:aController | aController view resetDisplayInterlock; displayDeEmphasized].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'dmu 9/17/2010 16:39' prior: 20251002!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: []			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] forkAt: Processor thisProcess priority + 1]]! !----End fileIn of /Users/smarr/Projects/PhD/IBM/github/image.st/RVM-multicore-support.mvc.st----!----QUIT----#(22 November 2010 5:35:21 pm) rvm-base.image priorSource: 4044!----STARTUP----#(8 March 2011 10:44:08 am) as /Users/smarr/Projects/PhD/IBM/images/rvm-base/rvm-base.image!----QUIT/NOSAVE----#(8 March 2011 10:44:15 am) rvm-base.image priorSource: 79272!----STARTUP----#(8 March 2011 3:50:34 pm) as /mnt/hgfs/smarr/Projects/PhD/IBM/images/rvm-base/rvm-base.image!----QUIT/NOSAVE----#(8 March 2011 3:50:47 pm) rvm-base.image priorSource: 79272!----STARTUP----#(9 March 2011 3:07:16 pm) as /Users/smarr/Projects/PhD/IBM/renaissance-opensource/rvm-base.image!!SmalltalkImage methodsFor: 'nil' stamp: 'sm 3/9/2011 15:09'!saveAs: newName	"Save the image  under the new name."	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !----STARTUP----#(9 March 2011 3:12:37 pm) as /Users/smarr/Projects/PhD/IBM/renaissance-opensource/rvm-base.image!!StandardSystemView methodsFor: 'nil' stamp: 'sm 3/9/2011 15:14'!displayClosingGuardBoxIfNeeded	"display closing guard active, if true"	| aRect |	self controller preventClosing ifTrue:[		aRect _ self closeBoxFrame.		self closingGuardIcon displayOn: Display at: aRect origin clippingBox: aRect rule: Form over fillColor: nil].! !!StandardSystemView methodsFor: 'as yet unclassified' stamp: 'sm 3/9/2011 15:15'!closingGuardIcon^(ColorForm	extent: 11@11	depth: 1	fromArray: #( 0 520093696 1065353216 830472192 830472192 2143289344 2143289344 2143289344 2143289344 2143289344 0)	offset: 0@0)	colorsFromArray: #(#(1.0 1.0 1.0)#(0.0 0.0 0.0)   )! !!StandardSystemView methodsFor: 'as yet unclassified' stamp: 'sm 3/9/2011 15:16'!preventClosing	"Answer the value of preventClosing"	preventClosing isNil ifTrue:[self preventClosing: false].	^ preventClosing! !!StandardSystemView methodsFor: 'as yet unclassified' stamp: 'sm 3/9/2011 15:16'!preventClosing: anObject	"Set the value of preventClosing"	preventClosing _ anObject! !----SNAPSHOT----#(9 March 2011 3:16:41 pm) rvm-base.image priorSource: 79272!----QUIT----#(9 March 2011 3:17:05 pm) rvm-base.image priorSource: 81379!----STARTUP----#(9 March 2011 3:17:36 pm) as /Users/smarr/Projects/PhD/IBM/renaissance-opensource/rvm-base.image!!SmalltalkImage methodsFor: 'nil' stamp: 'sm 3/9/2011 15:18'!saveAs: newName	"Save the image  under the new name."	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !----STARTUP----#(9 March 2011 3:19:18 pm) as /Users/smarr/Projects/PhD/IBM/renaissance-opensource/rvm-base.image!!StandardSystemController methodsFor: 'nil' stamp: 'sm 3/9/2011 15:20'!preventClosing: anObject	"Set the value of preventClosing"	preventClosing _ anObject! !!StandardSystemController methodsFor: 'as yet unclassified' stamp: 'sm 3/9/2011 15:21'!preventClosing	"Answer the value of preventClosing"	preventClosing isNil ifTrue:[self preventClosing: false].	^ preventClosing! !StandardSystemView removeSelector: #preventClosing!StandardSystemView removeSelector: #preventClosing:!!SmalltalkImage methodsFor: 'nil' stamp: 'sm 3/9/2011 15:22'!saveAs: newName	"Save the image  under the new name."	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !----SNAPSHOT----#(9 March 2011 3:22:06 pm) rvm-base.image priorSource: 81458!----STARTUP----#(11 March 2011 11:44:06 pm) as /Users/smarr/Projects/PhD/IBM/renaissance-opensource/rvm-base.image!!Color class methodsFor: 'named colors' stamp: 'sm 3/11/2011 23:45'!colorChart	^ ColorChart! !----STARTUP----#(17 March 2011 9:28:41 am) as /Users/smarr/Projects/PhD/IBM/DBD2011/squeak-svn/iOS/vm/iPhone/iPhone.image!(FileStream readOnlyFileNamed: 'FileInAllRenaissanceCode.st') fileIn.Preferences disable: #warnIfNoSourcesFile.!(FileStream readOnlyFileNamed: 'FileInAllRenaissanceCode.st') fileIn.Preferences disable: #warnIfNoSourcesFile.!----QUIT----#(17 March 2011 9:31:25 am) iPhone.image priorSource: 82979!